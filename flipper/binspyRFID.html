<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BinSpy RFID - Checkpoint Tracking</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link rel="icon" type="image/png" href="https://i.imgur.com/dZR7M8C.png">
    <link rel="apple-touch-icon" href="https://i.imgur.com/dZR7M8C.png">
    <style>
        html, body {
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            background-color: #f5f5f7;
            color: #1d1d1f;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 12px 15px;
            -webkit-font-smoothing: antialiased;
        }

        .page {
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 8px 0 4px;
            gap: 12px;
            flex-wrap: wrap;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
        }

        .logo {
            height: 38px;
            flex-shrink: 0;
        }

        .header-title {
            font-size: 1.25em;
            font-weight: 600;
            color: #1d1d1f;
            text-align: left;
            flex: 1;
            min-width: 0;
        }

        .header-title span {
            display: block;
            font-size: 0.78em;
            font-weight: 500;
            color: #5f5f62;
            margin-top: 2px;
        }

        .home-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 999px;
            border: 1px solid #d2d2d7;
            background-color: #ffffff;
            text-decoration: none;
            color: #007aff;
            flex-shrink: 0;
            transition: background-color 0.18s, box-shadow 0.18s, transform 0.08s;
        }

        .home-link svg {
            width: 18px;
            height: 18px;
        }

        .home-link:active {
            transform: scale(0.96);
            box-shadow: 0 1px 4px rgba(0,0,0,0.18);
        }

        .container {
            width: 100%;
        }

        .controls-row {
            background-color: #ffffff;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #d2d2d7;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
        }

        .view-toggle {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .view-btn, .export-btn, .nav-btn, .filter-btn, .refresh-btn {
            padding: 10px 18px;
            border: 1px solid #d2d2d7;
            background-color: #ffffff;
            color: #1d1d1f;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 15px;
            min-height: 40px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            white-space: nowrap;
        }

        .view-btn:active, .filter-btn:active {
            transform: scale(0.97);
        }

        .view-btn.active {
            background-color: #007aff;
            color: white;
            border-color: #007aff;
        }

        .export-btn {
            background-color: #34c759;
            color: white;
            border-color: #34c759;
        }

        .export-btn:active {
            background-color: #2fb350;
            transform: scale(0.97);
        }

        .refresh-btn {
            background-color: #007aff;
            color: white;
            border-color: #007aff;
        }

        .refresh-btn:active {
            background-color: #0056b3;
            transform: scale(0.97);
        }

        .aggregation-info {
            background-color: #e3f2fd;
            color: #1976d2;
            padding: 10px 14px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 0.9em;
            border: 1px solid #90caf9;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .aggregation-info svg {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background-color: #ffffff;
            padding: 18px 16px;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #d2d2d7;
            text-align: center;
        }

        .stat-number {
            font-size: 2.2em;
            font-weight: bold;
            margin-bottom: 6px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-card.detections .stat-number {
            color: #007aff;
        }

        .stat-card.bins .stat-number {
            color: #34c759;
        }

        .stat-card.today .stat-number {
            color: #ff9500;
        }

        .stat-card.recent .stat-number {
            color: #af52de;
        }

        .bins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .bin-card {
            background-color: #ffffff;
            padding: 14px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #d2d2d7;
            transition: transform 0.2s, box-shadow 0.2s;
            border-left: 4px solid #007aff;
        }

        .bin-card:active {
            transform: scale(0.98);
        }

        .bin-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .bin-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #1d1d1f;
            flex: 1;
        }

        .detection-count {
            background-color: #007aff;
            color: white;
            padding: 4px 10px;
            border-radius: 999px;
            font-weight: 700;
            font-size: 0.85em;
        }

        .visit-count {
            background-color: #34c759;
            color: white;
            padding: 4px 10px;
            border-radius: 999px;
            font-weight: 700;
            font-size: 0.85em;
            margin-left: 6px;
        }

        .bin-info {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 6px 10px;
            margin-bottom: 10px;
            font-size: 0.85em;
        }

        .bin-info-label {
            font-weight: 600;
            color: #666;
        }

        .bin-info-value {
            color: #1d1d1f;
        }

        .bin-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
            margin-right: 6px;
            margin-top: 4px;
        }

        .badge-size {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .badge-waste {
            background-color: #f3e5f5;
            color: #7b1fa2;
        }

        .badge-signal {
            background-color: #e8f5e9;
            color: #388e3c;
        }

        .badge-signal.poor {
            background-color: #ffebee;
            color: #c62828;
        }

        .last-seen {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
            font-size: 0.8em;
            color: #666;
        }

        .loading {
            text-align: center;
            color: #1d1d1f;
            font-size: 1.25em;
            padding: 40px 20px;
        }

        .error {
            background-color: #ffe5e5;
            color: #c41e3a;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin: 15px 0;
            border: 1px solid #ffcccc;
        }

        .filters {
            background-color: #ffffff;
            padding: 14px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #d2d2d7;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-label {
            font-size: 0.85em;
            color: #666;
            font-weight: 600;
            white-space: nowrap;
        }

        .filter-btn {
            padding: 8px 14px;
            min-height: 36px;
            font-size: 0.9em;
        }

        .filter-btn.active {
            background-color: #007aff;
            color: white;
            border-color: #007aff;
        }

        .search-box {
            flex: 1;
            min-width: 180px;
            padding: 10px 14px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 15px;
            background-color: #ffffff;
            min-height: 40px;
        }

        .search-box:focus {
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
        }

        .timeline-container {
            background-color: #ffffff;
            padding: 16px;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #d2d2d7;
            margin-bottom: 20px;
        }

        .timeline-header {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1d1d1f;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .timeline {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 600px;
            overflow-y: auto;
        }

        .timeline-event {
            display: flex;
            gap: 12px;
            padding: 12px;
            border-radius: 8px;
            background-color: #f8f9fa;
            border-left: 4px solid;
            transition: transform 0.2s;
        }

        .timeline-event.aggregated {
            background-color: #f0f8ff;
        }

        .timeline-event:hover {
            transform: translateX(4px);
        }

        .timeline-time-col {
            flex-shrink: 0;
            width: 100px;
            text-align: right;
        }

        .timeline-time {
            font-weight: 700;
            color: #007aff;
            font-size: 0.95em;
        }

        .timeline-date {
            font-size: 0.75em;
            color: #666;
            margin-top: 2px;
        }

        .timeline-content {
            flex: 1;
        }

        .timeline-bin-name {
            font-weight: 600;
            font-size: 1em;
            color: #1d1d1f;
            margin-bottom: 4px;
        }

        .timeline-details {
            font-size: 0.85em;
            color: #666;
        }

        .timeline-duration {
            font-size: 0.8em;
            color: #34c759;
            font-weight: 600;
            margin-top: 4px;
        }

        .timeline-chart-container {
            background-color: #ffffff;
            padding: 16px;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #d2d2d7;
            margin-bottom: 20px;
        }

        .timeline-chart-header {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1d1d1f;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .timeline-filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 15px;
        }

        .selected-bins-display {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 6px;
            min-height: 40px;
            align-items: center;
        }

        .selected-bins-display.empty {
            display: none;
        }

        .bin-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background-color: #007aff;
            color: white;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .bin-tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            line-height: 1;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .bin-tag-remove:hover {
            opacity: 1;
        }

        .filter-hint {
            font-size: 0.8em;
            color: #666;
            font-style: italic;
            margin-top: 4px;
        }

        .timeline-filter-group {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .timeline-filter-label {
            font-size: 0.85em;
            color: #666;
            font-weight: 600;
            white-space: nowrap;
        }

        .bin-checkbox-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 8px;
            padding: 12px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #d2d2d7;
            max-width: 100%;
        }

        .bin-checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background-color: #ffffff;
            border-radius: 6px;
            border: 1px solid #d2d2d7;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .bin-checkbox-item:hover {
            border-color: #007aff;
            box-shadow: 0 2px 4px rgba(0, 122, 255, 0.1);
        }

        .bin-checkbox-item.checked {
            border-color: #007aff;
            background-color: #e3f2fd;
        }

        .bin-checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #007aff;
        }

        .bin-checkbox-label {
            flex: 1;
            cursor: pointer;
            font-size: 0.9em;
            user-select: none;
        }

        .bin-color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .bin-select-all {
            grid-column: 1 / -1;
            font-weight: 600;
            background-color: #007aff;
            color: white;
            border-color: #007aff;
        }

        .bin-select-all:hover {
            background-color: #0056b3;
        }

        .bin-select-all input[type="checkbox"] {
            accent-color: white;
        }

        .granularity-btn {
            padding: 8px 14px;
            border: 1px solid #d2d2d7;
            background-color: #ffffff;
            color: #1d1d1f;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 0.9em;
            min-height: 36px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            white-space: nowrap;
        }

        .granularity-btn:active {
            transform: scale(0.97);
        }

        .granularity-btn.active {
            background-color: #007aff;
            color: white;
            border-color: #007aff;
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
            margin-bottom: 10px;
        }

        .chart-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
            font-size: 0.9em;
        }

        .chart-stat-item {
            display: flex;
            flex-direction: column;
        }

        .chart-stat-label {
            color: #666;
            font-size: 0.85em;
            margin-bottom: 2px;
        }

        .chart-stat-value {
            font-weight: 700;
            font-size: 1.1em;
            color: #007aff;
        }

        .calendar-container {
            background-color: #ffffff;
            padding: 14px;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #d2d2d7;
            margin-bottom: 10px;
            width: 100%;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .calendar-nav {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .nav-btn {
            padding: 8px 12px;
            background-color: #007aff;
            color: white;
            border: none;
            border-radius: 8px;
            min-height: 36px;
            font-size: 0.9rem;
        }

        .nav-btn:active {
            background-color: #0056b3;
            transform: scale(0.97);
        }

        .calendar-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #1d1d1f;
            text-align: center;
            flex: 1 1 140px;
        }

        .month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 6px;
        }

        .day-header {
            text-align: center;
            font-weight: 600;
            padding: 8px 4px;
            color: #007aff;
            font-size: 0.82em;
        }

        .day-cell {
            min-height: 70px;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            padding: 6px 4px;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #ffffff;
        }

        .day-cell:active {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.2);
        }

        .day-cell.other-month {
            opacity: 0.3;
        }

        .day-number {
            font-weight: 600;
            margin-bottom: 4px;
            color: #1d1d1f;
            font-size: 0.9em;
        }

        .day-count {
            background-color: #007aff;
            color: white;
            padding: 3px 6px;
            border-radius: 999px;
            font-size: 0.75em;
            font-weight: 700;
            display: inline-block;
        }

        footer {
            margin-top: auto;
            text-align: center;
            padding: 15px 20px 10px;
            font-size: 12px;
            background-color: #f5f5f7;
            color: #1d1d1f;
        }

        .last-updated {
            text-align: center;
            color: #666;
            margin: 8px 0 12px 0;
            font-size: 0.82em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .refresh-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #34c759;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .refresh-indicator.active {
            opacity: 1;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        @media screen and (max-width: 768px) {
            body {
                padding: 10px 10px 14px;
            }

            .header-title {
                font-size: 1.1em;
            }

            .bins-grid {
                grid-template-columns: 1fr;
            }

            .timeline-time-col {
                width: 70px;
                font-size: 0.9em;
            }

            .filter-group {
                width: 100%;
                justify-content: flex-start;
                margin-left: 0 !important;
            }

            .filter-label {
                width: 100%;
            }

            /* Dashboard filters mobile optimization */
            .filters {
                gap: 12px;
                flex-direction: column;
                align-items: stretch;
            }

            .search-box {
                width: 100%;
                min-width: 100%;
            }

            #toggleDetectionsBtn {
                width: 100%;
                margin-left: 0 !important;
                margin-right: auto !important;
            }

            /* Timeline view mobile optimizations */
            .timeline-filters {
                flex-direction: column;
                align-items: stretch;
            }

            .timeline-filter-group {
                width: 100%;
            }

            /* Center the entire bin filter container on mobile */
            .timeline-filter-group:has(.bin-checkbox-container) {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .bin-checkbox-container {
                grid-template-columns: repeat(3, 1fr);
                max-height: 400px;
                overflow-y: auto;
                gap: 6px;
                width: fit-content;
                margin: 0 auto;
            }

            .bin-checkbox-item {
                padding: 6px 6px;
                font-size: 0.8em;
                width: 100%;
            }

            .bin-checkbox-label {
                font-size: 0.85em;
            }

            .bin-checkbox-item input[type="checkbox"] {
                width: 14px;
                height: 14px;
            }

            .bin-color-indicator {
                width: 8px;
                height: 8px;
            }

            .timeline-filter-label {
                width: 100%;
                margin-bottom: 6px;
            }

            /* Show mobile time buttons, hide dropdown */
            #timelineFilter {
                display: none !important;
            }

            .mobile-time-buttons {
                display: flex !important;
                flex-wrap: wrap;
                gap: 6px;
                width: 100%;
            }

            .mobile-time-buttons .filter-btn {
                flex: 1 1 calc(50% - 3px);
                min-width: 0;
                font-size: 0.85em;
                padding: 8px 12px;
            }

            .granularity-btn {
                flex: 1;
                min-width: 0;
                font-size: 0.75em;
                padding: 6px 8px;
            }

            .chart-wrapper {
                height: 250px;
            }

            .chart-stats {
                font-size: 0.85em;
                gap: 12px;
            }

            .chart-stat-item {
                min-width: 100px;
                flex: 1 1 auto;
            }

            .chart-stat-label {
                font-size: 0.75em;
            }

            .chart-stat-value {
                font-size: 1em;
            }

            .timeline-chart-header {
                font-size: 1.1em;
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .selected-bins-display {
                font-size: 0.85em;
            }

            .bin-tag {
                font-size: 0.75em;
                padding: 4px 8px;
            }

            /* Make controls row more mobile friendly */
            .controls-row {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }

            .view-toggle {
                width: 100%;
                justify-content: space-between;
            }

            .view-btn {
                flex: 1;
                font-size: 0.85em;
                padding: 8px 12px;
            }

            /* Stats cards on mobile */
            .stats {
                gap: 10px;
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }

            .stat-card {
                padding: 14px 12px;
            }

            .stat-number {
                font-size: 1.8em;
            }

            .stat-label {
                font-size: 0.8em;
            }

            /* Bin cards on mobile */
            .bin-card {
                padding: 12px;
            }

            .bin-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .bin-name {
                font-size: 1em;
            }

            .visit-count,
            .detection-count {
                font-size: 0.8em;
            }

            /* Date picker group on mobile */
            #datepickerGroup {
                width: 100%;
            }

            #customDatePicker {
                flex: 1;
                min-width: 150px;
            }

            #clearDateBtn {
                padding: 8px 14px;
            }

            /* Weeks back group on mobile */
            #weeksBackGroup {
                width: 100%;
            }

            #weeksBackGroup .filter-btn {
                flex: 1 1 calc(33.333% - 4px);
                min-width: 0;
                font-size: 0.75em;
                padding: 6px 8px;
            }
        }
    </style>
</head>
<body>
<div class="page">
    <header>
        <div class="header-left">
            <img src="https://i.imgur.com/iB983sa.png" alt="BinSpy Logo" class="logo">
            <h1 class="header-title">
                BinSpy RFID Checkpoint Tracker
                <span style="display: flex; justify-content: space-between; align-items: center; gap: 10px; font-size: 0.78em; font-weight: 500; margin-top: 2px;">
                    <span style="color: #5f5f62;">Footscray</span>
                    <span id="heartbeatStatus" style="color: #666;">Loading heartbeat...</span>
                </span>
            </h1>
        </div>
        <a href="menu.html" class="home-link" aria-label="Back to BinSpy menu">
            <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M4 11L12 4L20 11V20H14V14H10V20H4V11Z"
                      fill="none"
                      stroke="currentColor"
                      stroke-width="1.8"
                      stroke-linecap="round"
                      stroke-linejoin="round"/>
            </svg>
        </a>
    </header>

    <div class="container">
        <div class="loading" id="loading">Loading RFID data...</div>
        <div class="error" id="error" style="display: none;"></div>

        <div id="content" style="display: none;">
            <div class="aggregation-info">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                </svg>
                <span>Detections are grouped into visits. Consecutive detections within <strong>1 hour</strong> are combined into a single visit.</span>
            </div>

            <div class="controls-row">
                <div class="view-toggle">
                    <button class="view-btn active" data-view="dashboard">Dashboard</button>
                    <button class="view-btn" data-view="timeline">Timeline</button>
                    <button class="view-btn" data-view="calendar">Calendar</button>
                </div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; flex: 0 1 auto;">
                    <button class="refresh-btn" id="refreshBtn" onclick="manualRefresh()">
                        Refresh
                    </button>
                    <button class="export-btn" id="exportBtn" onclick="exportToCSV()">
                        Export CSV
                    </button>
                </div>
            </div>

            <div class="last-updated" id="lastUpdated">
                <span class="refresh-indicator" id="refreshIndicator"></span>
                <span id="lastUpdatedText"></span>
            </div>

            <div id="dashboardView">
                <div class="stats" id="stats"></div>

                <div class="filters">
                    <input type="text" class="search-box" id="searchBox" placeholder="Search bins...">
                    <div class="filter-group">
                        <span class="filter-label">Waste Type:</span>
                        <button class="filter-btn active" data-filter-type="waste" data-filter="all">All</button>
                        <div id="wasteTypeFilters"></div>
                    </div>
                    <div class="filter-group">
                        <span class="filter-label">Bin Size:</span>
                        <button class="filter-btn active" data-filter-type="size" data-filter="all">All</button>
                        <div id="binSizeFilters"></div>
                    </div>
                    <div class="filter-group">
                        <button class="filter-btn" id="toggleDetectionsBtn" style="margin-left: auto;">
                            Show Detections
                        </button>
                    </div>
                </div>

                <div class="bins-grid" id="binsGrid"></div>
            </div>

            <div id="timelineView" class="hidden">
                <div class="timeline-chart-container">
                    <div class="timeline-chart-header">
                        <span>Visit Distribution</span>
                        <button class="filter-btn" id="clearFiltersBtn" style="display: none;">Clear Filters</button>
                    </div>
                    
                    <div class="timeline-filters">
                        <div class="timeline-filter-group" style="width: 100%; flex-direction: column; align-items: flex-start;">
                            <span class="timeline-filter-label">Filter by Bins:</span>
                            <div class="bin-checkbox-container" id="binCheckboxContainer">
                                <!-- Checkboxes will be populated here -->
                            </div>
                        </div>
                        
                        <div class="timeline-filter-group">
                            <span class="timeline-filter-label">Time Range:</span>
                            <select id="timelineFilter" style="padding: 6px 10px; border-radius: 6px; border: 1px solid #d2d2d7; min-height: 36px;">
                                <option value="all">All Time</option>
                                <option value="today">Today</option>
                                <option value="week" selected>This Week</option>
                                <option value="month">This Month</option>
                                <option value="custom">Custom Date</option>
                            </select>
                            <div class="mobile-time-buttons" style="display: none;">
                                <button class="filter-btn" data-time-filter="all">All Time</button>
                                <button class="filter-btn" data-time-filter="today">Today</button>
                                <button class="filter-btn active" data-time-filter="week">This Week</button>
                                <button class="filter-btn" data-time-filter="month">This Month</button>
                                <button class="filter-btn" data-time-filter="custom">Custom Date</button>
                            </div>
                        </div>
                        
                        <div class="timeline-filter-group" id="datepickerGroup" style="display: none;">
                            <span class="timeline-filter-label">Select Date:</span>
                            <input type="date" id="customDatePicker" style="padding: 6px 10px; border-radius: 6px; border: 1px solid #d2d2d7; min-height: 36px; font-size: 0.9em;">
                            <button class="filter-btn" id="clearDateBtn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">Clear Date</button>
                        </div>
                        
                        <div class="timeline-filter-group" id="weeksBackGroup" style="display: none;">
                            <span class="timeline-filter-label">Compare Weeks:</span>
                            <button class="filter-btn active" data-weeks-back="0">This Week Only</button>
                            <button class="filter-btn" data-weeks-back="1">+ 1 Week</button>
                            <button class="filter-btn" data-weeks-back="2">+ 2 Weeks</button>
                            <button class="filter-btn" data-weeks-back="3">+ 3 Weeks</button>
                            <button class="filter-btn" data-weeks-back="4">+ 4 Weeks</button>
                        </div>
                        
                        <div class="timeline-filter-group">
                            <span class="timeline-filter-label">Group By:</span>
                            <button class="granularity-btn active" data-granularity="auto">Auto</button>
                            <button class="granularity-btn" data-granularity="hour">Hour</button>
                            <button class="granularity-btn" data-granularity="day">Day</button>
                            <button class="granularity-btn" data-granularity="week">Week</button>
                            <button class="granularity-btn" data-granularity="month">Month</button>
                        </div>
                    </div>
                    
                    <div class="selected-bins-display empty" id="selectedBinsDisplay">
                        <span style="font-size: 0.85em; color: #666; font-weight: 600; margin-right: 8px;">Filtered Bins:</span>
                        <div id="selectedBinsTags"></div>
                    </div>
                    
                    <div class="chart-wrapper">
                        <canvas id="timelineChart"></canvas>
                    </div>
                    
                    <div class="chart-stats" id="chartStats" style="display: none;"></div>
                </div>

                <div class="timeline-container">
                    <div class="timeline-header">
                        <span>Recent Visits</span>
                    </div>
                    <div class="timeline" id="timeline"></div>
                </div>
            </div>

            <div id="calendarView" class="hidden">
                <div class="calendar-container">
                    <div class="calendar-header">
                        <div class="calendar-nav">
                            <button class="nav-btn" id="prevBtn">← Prev</button>
                            <button class="nav-btn" id="todayBtn">Today</button>
                            <button class="nav-btn" id="nextBtn">Next →</button>
                        </div>
                        <div class="calendar-title" id="calendarTitle"></div>
                    </div>
                    <div id="calendarContent"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<footer>
    2025 | Wasted by Shrunk | All Rights Reserved
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
<script>
    const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTPVoP6ihWhIntuCPMue-FMy8bWqa8YjsDeuaBiLPbm3tdWezDP08uxy2WybrTmLEiFr9UMLVzr_TJF/pub?gid=0&single=true&output=csv';
    const HEARTBEAT_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTPVoP6ihWhIntuCPMue-FMy8bWqa8YjsDeuaBiLPbm3tdWezDP08uxy2WybrTmLEiFr9UMLVzr_TJF/pub?gid=1744529929&single=true&output=csv';

    // Aggregation settings - adjust this to change grouping behavior
    const AGGREGATION_WINDOW_MS = 60 * 60 * 1000; // 1 hour
    
    // Color palette for multiple bins - optimized for maximum differentiation
    const BIN_COLORS = [
        '#007aff', // Blue
        '#34c759', // Green
        '#ff9500', // Orange
        '#af52de', // Purple
        '#ff3b30', // Red
        '#5ac8fa', // Cyan
        '#ffcc00', // Yellow
        '#ff2d55', // Pink
        '#5856d6', // Indigo
        '#00c7be', // Teal
        '#8b4513', // Saddle Brown
        '#32cd32', // Lime Green
        '#ff1493', // Deep Pink
        '#00bfff', // Deep Sky Blue
        '#ff8c00', // Dark Orange
        '#9370db', // Medium Purple
        '#ff6347', // Tomato Red
        '#20b2aa', // Light Sea Green
    ];
    
    let binColorMap = new Map();

    let allDetections = [];
    let aggregatedVisits = [];
    let lastHeartbeat = null;
    let currentView = 'dashboard';
    let searchTerm = '';
    let wasteTypeFilter = 'all';
    let binSizeFilter = 'all';
    let timelineFilter = 'week'; // Default to "This Week"
    let timelineGranularity = 'auto';
    let selectedBins = ['all'];
    let customDate = null; // For viewing specific days
    let weeksBack = 0; // How many previous weeks of same weekday to show
    let currentDate = new Date();
    let timelineChart = null;
    let showDetectionCount = false; // Default to hide detection counts on dashboard cards

    // Helper function to format dates as DD/MM/YYYY HH:MM:SS
    function formatDateTime(date) {
        if (!date) return 'N/A';
        const day = date.getDate().toString().padStart(2, '0');
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const year = date.getFullYear();
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        const seconds = date.getSeconds().toString().padStart(2, '0');
        return `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
    }

    // Australian Standard waste bin colors
    function getAustralianWasteColor(wasteType) {
        const type = (wasteType || '').toLowerCase();
        
        if (type.includes('co-mingle') || type.includes('comingle') || type.includes('recycl')) {
            return '#FFD700'; // Yellow - Co-mingled recycling
        } else if (type.includes('general') || type.includes('waste')) {
            return '#DC143C'; // Red - General waste
        } else if (type.includes('green') || type.includes('organic') || type.includes('garden')) {
            return '#228B22'; // Green - Organics/Garden
        } else if (type.includes('blue') || type.includes('paper') || type.includes('cardboard')) {
            return '#1E90FF'; // Blue - Paper/Cardboard
        } else if (type.includes('purple') || type.includes('glass')) {
            return '#9370DB'; // Purple - Glass (some councils)
        } else {
            return '#007aff'; // Default blue
        }
    }

    function parseTimestamp(timestamp) {
        if (timestamp instanceof Date) {
            return timestamp;
        }
        
        if (typeof timestamp === 'string') {
            const parts = timestamp.trim().split(' ');
            if (parts.length >= 2) {
                const dateParts = parts[0].split('/');
                const timeParts = parts[1].split(':');
                
                if (dateParts.length === 3 && timeParts.length >= 2) {
                    const day = parseInt(dateParts[0]);
                    const month = parseInt(dateParts[1]) - 1;
                    const year = parseInt(dateParts[2]);
                    const hour = parseInt(timeParts[0]);
                    const minute = parseInt(timeParts[1]);
                    const second = parseInt(timeParts[2] || 0);
                    
                    return new Date(year, month, day, hour, minute, second);
                }
            }
            
            return new Date(timestamp);
        }
        
        return new Date();
    }

    function aggregateDetections(detections) {
        if (detections.length === 0) return [];

        // Sort by MAC and timestamp
        const sorted = [...detections].sort((a, b) => {
            const macCompare = (a.MAC || a.mac || '').localeCompare(b.MAC || b.mac || '');
            if (macCompare !== 0) return macCompare;
            return a.timestamp - b.timestamp;
        });

        const visits = [];
        let currentVisit = null;

        sorted.forEach(detection => {
            const mac = detection.MAC || detection.mac;
            
            if (!currentVisit || 
                currentVisit.mac !== mac || 
                (detection.timestamp - currentVisit.endTime) > AGGREGATION_WINDOW_MS) {
                
                // Start a new visit
                if (currentVisit) {
                    visits.push(currentVisit);
                }
                
                currentVisit = {
                    mac: mac,
                    name: detection.Name || detection.name || 'Unknown',
                    binSize: detection['Bin Size'] || detection.binSize || 'Unknown',
                    wasteType: detection['Waste Type'] || detection.wasteType || 'Unknown',
                    startTime: detection.timestamp,
                    endTime: detection.timestamp,
                    detections: [detection],
                    detectionCount: 1,
                    avgRSSI: parseFloat(detection.RSSI || detection.rssi || 0),
                    qualities: [detection.Quality || detection.quality]
                };
            } else {
                // Continue current visit
                currentVisit.endTime = detection.timestamp;
                currentVisit.detections.push(detection);
                currentVisit.detectionCount++;
                
                const rssi = parseFloat(detection.RSSI || detection.rssi);
                if (!isNaN(rssi)) {
                    currentVisit.avgRSSI = (currentVisit.avgRSSI * (currentVisit.detectionCount - 1) + rssi) / currentVisit.detectionCount;
                }
                
                const quality = detection.Quality || detection.quality;
                if (quality) {
                    currentVisit.qualities.push(quality);
                }
            }
        });

        // Add the last visit
        if (currentVisit) {
            visits.push(currentVisit);
        }

        // Calculate duration and format data
        visits.forEach(visit => {
            visit.durationMs = visit.endTime - visit.startTime;
            visit.durationFormatted = formatDuration(visit.durationMs);
            visit.avgRSSI = visit.avgRSSI.toFixed(1);
            visit.avgQuality = visit.qualities[visit.qualities.length - 1] || 'Unknown';
        });

        // Filter to ONLY include visits between 1 AM (01:00) and 7 AM (07:00)
        const filteredVisits = visits.filter(visit => {
            const visitHour = visit.endTime.getHours();
            // Keep ONLY visits between 1 AM (1) and 6:59 AM (6 inclusive)
            // Include: 1, 2, 3, 4, 5, 6 (which is 01:00-06:59)
            return visitHour >= 1 && visitHour < 7;
        });

        return filteredVisits.sort((a, b) => b.endTime - a.endTime);
    }

    function formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        if (seconds < 60) return `${seconds}s`;
        
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        
        if (minutes < 60) {
            return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`;
        }
        
        const hours = Math.floor(minutes / 60);
        const remainingMinutes = minutes % 60;
        return `${hours}h ${remainingMinutes}m`;
    }

    function getBinStats() {
        const uniqueBins = new Map();
        
        // Get today's start time
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        // Filter visits to only today
        const todayVisits = aggregatedVisits.filter(v => v.endTime >= today);
        
        // First, initialize all bins from ALL detections (not just filtered visits)
        // This ensures we show all bins even if they have no visits in the 1-7 AM window
        allDetections.forEach(detection => {
            const mac = detection.MAC || detection.mac;
            if (!uniqueBins.has(mac)) {
                uniqueBins.set(mac, {
                    name: detection.Name || detection.name || 'Unknown',
                    binSize: detection['Bin Size'] || detection.binSize || 'Unknown',
                    wasteType: detection['Waste Type'] || detection.wasteType || 'Unknown',
                    visits: [],
                    totalDetections: 0,
                    lastSeen: null,
                    avgRSSI: 0,
                    avgQuality: ''
                });
            }
        });
        
        // Now populate with today's filtered data (1-7 AM visits only)
        todayVisits.forEach(visit => {
            const bin = uniqueBins.get(visit.mac);
            if (bin) {
                bin.visits.push(visit);
                bin.totalDetections += visit.detectionCount;
                
                if (!bin.lastSeen || visit.endTime > bin.lastSeen) {
                    bin.lastSeen = visit.endTime;
                }
            }
        });
        
        // Calculate averages for bins with visits today
        uniqueBins.forEach((bin, mac) => {
            if (bin.visits.length > 0) {
                const rssiValues = bin.visits.map(v => parseFloat(v.avgRSSI)).filter(v => !isNaN(v));
                if (rssiValues.length > 0) {
                    bin.avgRSSI = (rssiValues.reduce((a, b) => a + b, 0) / rssiValues.length).toFixed(1);
                }
                
                bin.avgQuality = bin.visits[0].avgQuality;
            }
        });
        
        return uniqueBins;
    }

    function getUniqueWasteTypes() {
        const types = new Set();
        aggregatedVisits.forEach(v => {
            if (v.wasteType) types.add(v.wasteType);
        });
        return Array.from(types).sort();
    }

    function getUniqueBinSizes() {
        const sizes = new Set();
        aggregatedVisits.forEach(v => {
            if (v.binSize) sizes.add(v.binSize);
        });
        return Array.from(sizes).sort();
    }

    async function loadHeartbeat() {
        try {
            const response = await fetch(HEARTBEAT_URL + '&t=' + new Date().getTime());
            const csvText = await response.text();

            Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.data && results.data.length > 0) {
                        const latest = results.data[results.data.length - 1];
                        const timestampStr = latest['System Time '] || latest['System Time'] || latest.Timestamp || latest.timestamp;
                        const parsedTimestamp = parseTimestamp(timestampStr);
                        
                        lastHeartbeat = {
                            timestamp: parsedTimestamp,
                            deviceTime: latest['Device Time'] || latest.deviceTime || 'Unknown',
                            status: latest.Status || latest.status || 'Unknown'
                        };
                        updateHeartbeatDisplay();
                    }
                },
                error: function(error) {
                    console.error('Error parsing heartbeat:', error);
                }
            });
        } catch (error) {
            console.error('Error fetching heartbeat:', error);
        }
    }

    function updateHeartbeatDisplay() {
        const statusElement = document.getElementById('heartbeatStatus');
        if (!statusElement) return;

        if (lastHeartbeat) {
            const now = new Date();
            const diffMs = now - lastHeartbeat.timestamp;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);

            let statusText = '';
            let statusColor = '';

            if (diffMins < 60) {
                statusText = `Last heartbeat: ${diffMins}m ago`;
                statusColor = '#34c759';
            } else if (diffHours < 2) {
                statusText = `Last heartbeat: ${diffHours}h ${diffMins % 60}m ago`;
                statusColor = '#34c759';
            } else if (diffHours < 3) {
                statusText = `Last heartbeat: ${diffHours}h ${diffMins % 60}m ago`;
                statusColor = '#ff9500';
            } else {
                statusText = `Last heartbeat: ${diffHours}h ${diffMins % 60}m ago`;
                statusColor = '#ff3b30';
            }

            statusElement.textContent = statusText;
            statusElement.style.color = statusColor;
        } else {
            statusElement.textContent = 'Waiting for heartbeat...';
            statusElement.style.color = '#666';
        }
    }

    async function loadData(isAutoRefresh = false) {
        const indicator = document.getElementById('refreshIndicator');
        if (indicator && isAutoRefresh) {
            indicator.classList.add('active');
        }

        try {
            const response = await fetch(CSV_URL + '&t=' + new Date().getTime());
            const csvText = await response.text();

            Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    allDetections = results.data.map(row => ({
                        ...row,
                        timestamp: parseTimestamp(row.Timestamp || row.timestamp)
                    }));

                    // Aggregate detections into visits
                    aggregatedVisits = aggregateDetections(allDetections);

                    loadHeartbeat();
                    populateFilters();
                    displayCurrentView();

                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('content').style.display = 'block';

                    if (indicator && isAutoRefresh) {
                        setTimeout(() => indicator.classList.remove('active'), 500);
                    }
                },
                error: function(error) {
                    showError('Error parsing CSV: ' + error.message);
                    if (indicator) {
                        indicator.classList.remove('active');
                    }
                }
            });
        } catch (error) {
            showError('Error loading data: ' + error.message);
            if (indicator) {
                indicator.classList.remove('active');
            }
        }
    }

    function showError(message) {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'block';
        document.getElementById('error').textContent = message;
    }

    function populateFilters() {
        const wasteTypes = getUniqueWasteTypes();
        const wasteTypeFilters = document.getElementById('wasteTypeFilters');
        wasteTypeFilters.innerHTML = wasteTypes.map(type => 
            `<button class="filter-btn" data-filter-type="waste" data-filter="${type}">${type}</button>`
        ).join('');

        const binSizes = getUniqueBinSizes();
        const binSizeFilters = document.getElementById('binSizeFilters');
        binSizeFilters.innerHTML = binSizes.map(size => 
            `<button class="filter-btn" data-filter-type="size" data-filter="${size}">${size}</button>`
        ).join('');

        // Populate timeline bin filter
        populateTimelineBinFilter();
    }

    function populateTimelineBinFilter() {
        const container = document.getElementById('binCheckboxContainer');
        if (!container) return;

        const uniqueBins = Array.from(getBinStats().entries())
            .map(([mac, data]) => ({
                mac,
                name: data.name,
                visits: data.visits.length
            }))
            .sort((a, b) => a.name.localeCompare(b.name));

        // Assign colors to bins
        binColorMap.clear();
        uniqueBins.forEach((bin, index) => {
            binColorMap.set(bin.mac, BIN_COLORS[index % BIN_COLORS.length]);
        });

        // Check if "All Bins" is selected
        const isAllSelected = selectedBins.includes('all');

        // Create "All Bins" checkbox
        let html = `
            <div class="bin-checkbox-item bin-select-all" id="binCheckAll">
                <input type="checkbox" id="checkbox-all" value="all" ${isAllSelected ? 'checked' : ''}>
                <label class="bin-checkbox-label" for="checkbox-all">All Bins</label>
            </div>
        `;

        // Create individual bin checkboxes - preserve selection state
        html += uniqueBins.map(bin => {
            const isSelected = selectedBins.includes(bin.mac);
            return `
                <div class="bin-checkbox-item ${isSelected ? 'checked' : ''}" data-mac="${bin.mac}">
                    <input type="checkbox" id="checkbox-${bin.mac}" value="${bin.mac}" ${isSelected ? 'checked' : ''}>
                    <div class="bin-color-indicator" style="background-color: ${binColorMap.get(bin.mac)}"></div>
                    <label class="bin-checkbox-label" for="checkbox-${bin.mac}">${bin.name}</label>
                </div>
            `;
        }).join('');

        container.innerHTML = html;

        // Add event listeners
        document.getElementById('checkbox-all').addEventListener('change', handleAllBinsCheckbox);
        
        uniqueBins.forEach(bin => {
            const checkbox = document.getElementById(`checkbox-${bin.mac}`);
            const item = checkbox.closest('.bin-checkbox-item');
            
            checkbox.addEventListener('change', () => handleBinCheckbox(bin.mac));
            item.addEventListener('click', (e) => {
                if (e.target.tagName !== 'INPUT') {
                    checkbox.checked = !checkbox.checked;
                    handleBinCheckbox(bin.mac);
                }
            });
        });

        // Add click handler for "All Bins" item
        const allItem = document.getElementById('binCheckAll');
        allItem.addEventListener('click', (e) => {
            if (e.target.tagName !== 'INPUT') {
                const checkbox = document.getElementById('checkbox-all');
                checkbox.checked = !checkbox.checked;
                handleAllBinsCheckbox();
            }
        });
    }

    function handleAllBinsCheckbox() {
        const allCheckbox = document.getElementById('checkbox-all');
        const container = document.getElementById('binCheckboxContainer');
        
        if (allCheckbox.checked) {
            // Uncheck all individual bins
            container.querySelectorAll('input[type="checkbox"]:not(#checkbox-all)').forEach(cb => {
                cb.checked = false;
                cb.closest('.bin-checkbox-item').classList.remove('checked');
            });
            selectedBins = ['all'];
            document.getElementById('clearFiltersBtn').style.display = 'none';
        }
        
        updateSelectedBinsDisplay();
        displayTimeline();
    }

    function handleBinCheckbox(mac) {
        const checkbox = document.getElementById(`checkbox-${mac}`);
        const item = checkbox.closest('.bin-checkbox-item');
        const allCheckbox = document.getElementById('checkbox-all');
        
        if (checkbox.checked) {
            item.classList.add('checked');
            // Uncheck "All Bins"
            allCheckbox.checked = false;
            document.getElementById('binCheckAll').classList.remove('checked');
            
            // Add to selected bins
            if (selectedBins.includes('all')) {
                selectedBins = [mac];
            } else if (!selectedBins.includes(mac)) {
                selectedBins.push(mac);
            }
        } else {
            item.classList.remove('checked');
            // Remove from selected bins
            selectedBins = selectedBins.filter(m => m !== mac);
            
            // If no bins selected, check "All"
            if (selectedBins.length === 0) {
                allCheckbox.checked = true;
                document.getElementById('binCheckAll').classList.add('checked');
                selectedBins = ['all'];
            }
        }

        // Show/hide clear filters button
        const clearBtn = document.getElementById('clearFiltersBtn');
        if (selectedBins.length > 0 && !selectedBins.includes('all')) {
            clearBtn.style.display = 'inline-flex';
        } else {
            clearBtn.style.display = 'none';
        }
        
        updateSelectedBinsDisplay();
        displayTimeline();
    }

    function updateSelectedBinsDisplay() {
        const display = document.getElementById('selectedBinsDisplay');
        const tagsContainer = document.getElementById('selectedBinsTags');
        
        if (!display || !tagsContainer) return;
        
        if (selectedBins.length === 0 || selectedBins.includes('all')) {
            display.classList.add('empty');
            return;
        }
        
        display.classList.remove('empty');
        
        // Get bin names for the selected MACs
        const binStats = getBinStats();
        const binTags = selectedBins.map(mac => {
            const binData = binStats.get(mac);
            if (!binData) return null;
            const color = binColorMap.get(mac) || '#007aff';
            
            return `
                <div class="bin-tag" style="background-color: ${color}">
                    <span>${binData.name}</span>
                    <span class="bin-tag-remove" data-mac="${mac}">×</span>
                </div>
            `;
        }).filter(tag => tag !== null).join('');
        
        tagsContainer.innerHTML = binTags;
        
        // Add click handlers for remove buttons
        document.querySelectorAll('.bin-tag-remove').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const macToRemove = e.target.dataset.mac;
                removeBinFromFilter(macToRemove);
            });
        });
    }

    function removeBinFromFilter(mac) {
        const checkbox = document.getElementById(`checkbox-${mac}`);
        if (checkbox) {
            checkbox.checked = false;
            checkbox.closest('.bin-checkbox-item').classList.remove('checked');
        }
        
        // Remove from selectedBins array
        selectedBins = selectedBins.filter(m => m !== mac);
        
        // If no bins selected, default to "All"
        if (selectedBins.length === 0) {
            selectedBins = ['all'];
            const allCheckbox = document.getElementById('checkbox-all');
            if (allCheckbox) {
                allCheckbox.checked = true;
                document.getElementById('binCheckAll').classList.add('checked');
            }
            document.getElementById('clearFiltersBtn').style.display = 'none';
        }
        
        updateSelectedBinsDisplay();
        displayTimeline();
    }

    function displayCurrentView() {
        document.getElementById('dashboardView').classList.toggle('hidden', currentView !== 'dashboard');
        document.getElementById('timelineView').classList.toggle('hidden', currentView !== 'timeline');
        document.getElementById('calendarView').classList.toggle('hidden', currentView !== 'calendar');

        if (currentView === 'dashboard') {
            displayDashboard();
        } else if (currentView === 'timeline') {
            restoreTimelineFilterStates();
            displayTimeline();
        } else if (currentView === 'calendar') {
            displayCalendar();
        }
        
        updateLastUpdated();
    }

    function restoreTimelineFilterStates() {
        // Restore mobile time range button states
        document.querySelectorAll('.mobile-time-buttons .filter-btn').forEach(btn => {
            if (btn.dataset.timeFilter === timelineFilter) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });

        // Restore granularity button states
        document.querySelectorAll('.granularity-btn').forEach(btn => {
            if (btn.dataset.granularity === timelineGranularity) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });

        // Show/hide date picker and weeks back based on filter
        const datepickerGroup = document.getElementById('datepickerGroup');
        const weeksBackGroup = document.getElementById('weeksBackGroup');
        if (timelineFilter === 'custom') {
            datepickerGroup.style.display = 'flex';
            weeksBackGroup.style.display = 'flex';
        } else {
            datepickerGroup.style.display = 'none';
            weeksBackGroup.style.display = 'none';
        }
    }

    function displayDashboard() {
        displayStats();
        displayBins();
    }

    function displayStats() {
        const totalDetections = allDetections.length;
        const uniqueBins = getBinStats().size;
        
        // Get today
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayVisits = aggregatedVisits.filter(v => v.endTime >= today).length;
        
        // Get start of this week (Monday)
        const now = new Date();
        const dayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
        const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // If Sunday, go back 6 days, otherwise go back to Monday
        const monday = new Date(now);
        monday.setDate(now.getDate() - daysToMonday);
        monday.setHours(0, 0, 0, 0);
        
        const weekVisits = aggregatedVisits.filter(v => v.endTime >= monday).length;

        document.getElementById('stats').innerHTML = `
            <div class="stat-card bins">
                <div class="stat-number">${uniqueBins}</div>
                <div class="stat-label">Unique Bins</div>
            </div>
            <div class="stat-card detections">
                <div class="stat-number">${weekVisits.toLocaleString()}</div>
                <div class="stat-label">Visits this Week</div>
            </div>
            <div class="stat-card today">
                <div class="stat-number">${todayVisits.toLocaleString()}</div>
                <div class="stat-label">Visits Today</div>
            </div>
        `;
    }

    function getSignalQuality(rssi) {
        const rssiNum = parseFloat(rssi);
        if (isNaN(rssiNum)) return { text: 'Unknown', class: '' };
        
        if (rssiNum >= -50) return { text: 'Excellent', class: '' };
        if (rssiNum >= -60) return { text: 'Good', class: '' };
        if (rssiNum >= -70) return { text: 'Fair', class: '' };
        return { text: 'Poor', class: 'poor' };
    }

    function displayBins() {
        let binStats = Array.from(getBinStats().entries()).map(([mac, data]) => ({
            mac,
            ...data
        }));

        if (wasteTypeFilter !== 'all') {
            binStats = binStats.filter(bin => bin.wasteType === wasteTypeFilter);
        }

        if (binSizeFilter !== 'all') {
            binStats = binStats.filter(bin => bin.binSize === binSizeFilter);
        }

        if (searchTerm) {
            binStats = binStats.filter(bin => {
                const searchLower = searchTerm.toLowerCase();
                return bin.name.toLowerCase().includes(searchLower) ||
                       bin.mac.toLowerCase().includes(searchLower) ||
                       bin.wasteType.toLowerCase().includes(searchLower);
            });
        }

        // Sort: bins with visits today first (by last seen), then bins without visits (alphabetically)
        binStats.sort((a, b) => {
            if (a.lastSeen && !b.lastSeen) return -1;
            if (!a.lastSeen && b.lastSeen) return 1;
            if (a.lastSeen && b.lastSeen) return b.lastSeen - a.lastSeen;
            return a.name.localeCompare(b.name);
        });

        const binsGrid = document.getElementById('binsGrid');

        if (binStats.length === 0) {
            binsGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #666;">No bins found</div>';
            return;
        }

        binsGrid.innerHTML = binStats.map(bin => {
            const wasteColor = getAustralianWasteColor(bin.wasteType);
            const hasVisitsToday = bin.visits.length > 0;
            
            return `
                <div class="bin-card" style="border-left-color: ${wasteColor}; opacity: ${hasVisitsToday ? '1' : '0.6'}">
                    <div class="bin-header">
                        <div class="bin-name">${bin.name}</div>
                        ${hasVisitsToday ? `
                            <div>
                                <span class="visit-count">${bin.visits.length} visits</span>
                                ${showDetectionCount ? `<span class="detection-count">${bin.totalDetections} detections</span>` : ''}
                            </div>
                        ` : `
                            <div>
                                <span style="color: #999; font-size: 0.85em; font-weight: 500;">No visits today</span>
                            </div>
                        `}
                    </div>
                    
                    <div style="margin: 12px 0;">
                        <span class="bin-badge badge-size">${bin.binSize}</span>
                        <span class="bin-badge badge-waste" style="background-color: ${wasteColor}33; color: ${wasteColor}; border: 1px solid ${wasteColor}66;">${bin.wasteType}</span>
                    </div>
                    
                    ${hasVisitsToday ? `
                        <div class="last-seen">
                            <strong>Last Seen:</strong> ${formatDateTime(bin.lastSeen)}
                        </div>
                    ` : `
                        <div class="last-seen" style="color: #999;">
                            <strong>Status:</strong> Not detected today
                        </div>
                    `}
                </div>
            `;
        }).join('');
    }

    function createTimelineChart(visits) {
        // Destroy existing chart if it exists
        if (timelineChart) {
            timelineChart.destroy();
        }

        if (visits.length === 0) {
            const ctx = document.getElementById('timelineChart');
            const parent = ctx.parentElement;
            parent.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No data to display</div>';
            document.getElementById('chartStats').innerHTML = '';
            return;
        }

        // Filter by selected bins
        let filteredVisits = visits;
        if (selectedBins.length > 0 && !selectedBins.includes('all')) {
            filteredVisits = visits.filter(v => selectedBins.includes(v.mac));
        }

        if (filteredVisits.length === 0) {
            const ctx = document.getElementById('timelineChart');
            const parent = ctx.parentElement;
            parent.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No visits found for selected bins</div>';
            document.getElementById('chartStats').innerHTML = '';
            return;
        }

        // Ensure canvas exists
        const chartWrapper = document.querySelector('.chart-wrapper');
        if (!chartWrapper.querySelector('canvas')) {
            chartWrapper.innerHTML = '<canvas id="timelineChart"></canvas>';
        }

        // Determine time range based on filter
        let startTime, endTime;
        const now = new Date();
        
        if (timelineFilter === 'today') {
            startTime = new Date(now);
            startTime.setHours(0, 0, 0, 0);
            endTime = new Date(now);
            endTime.setHours(23, 59, 59, 999);
        } else if (timelineFilter === 'week') {
            startTime = new Date(now - 7 * 24 * 60 * 60 * 1000);
            startTime.setHours(0, 0, 0, 0);
            endTime = new Date(now);
            endTime.setHours(23, 59, 59, 999);
        } else if (timelineFilter === 'month') {
            startTime = new Date(now - 30 * 24 * 60 * 60 * 1000);
            startTime.setHours(0, 0, 0, 0);
            endTime = new Date(now);
            endTime.setHours(23, 59, 59, 999);
        } else if (timelineFilter === 'custom' && customDate) {
            // Custom date - show selected day plus previous instances of same weekday
            if (weeksBack === 0) {
                // Just show the selected day
                startTime = new Date(customDate);
                startTime.setHours(0, 0, 0, 0);
                endTime = new Date(customDate);
                endTime.setHours(23, 59, 59, 999);
            } else {
                // Filter visits to only include the selected weekday across multiple weeks
                // We'll handle this differently - don't set startTime/endTime for range
                // Instead we'll filter to specific dates later
                startTime = new Date(customDate);
                startTime.setDate(startTime.getDate() - (weeksBack * 7));
                startTime.setHours(0, 0, 0, 0);
                endTime = new Date(customDate);
                endTime.setHours(23, 59, 59, 999);
            }
        } else {
            // All time - use min and max from actual data
            const times = filteredVisits.map(v => v.endTime.getTime());
            startTime = new Date(Math.min(...times));
            endTime = new Date(Math.max(...times));
        }

        // Determine granularity
        let actualGranularity = timelineGranularity;
        if (actualGranularity === 'auto') {
            // Auto-select based on time filter
            if (timelineFilter === 'today' || timelineFilter === 'custom') {
                actualGranularity = 'hour';
            } else if (timelineFilter === 'week') {
                actualGranularity = 'hour';
            } else if (timelineFilter === 'month') {
                actualGranularity = 'day';
            } else {
                actualGranularity = 'month';
            }
        }

        // Special filtering for custom date with multiple weeks
        if (timelineFilter === 'custom' && customDate && weeksBack > 0) {
            const targetWeekday = customDate.getDay();
            const targetDates = [];
            
            // Build list of dates to include (selected date plus N weeks back of same weekday)
            for (let i = 0; i <= weeksBack; i++) {
                const date = new Date(customDate);
                date.setDate(date.getDate() - (i * 7));
                targetDates.push(date.toDateString());
            }
            
            // Filter visits to only those on target dates
            filteredVisits = filteredVisits.filter(v => {
                return targetDates.includes(v.endTime.toDateString());
            });
        }

        // Group visits by time period based on granularity
        let groupedData = {};
        let labelFormat;
        let groupingFunction;
        let xAxisLabel;
        let incrementFunction;

        if (actualGranularity === 'hour') {
            if (timelineFilter === 'custom' && customDate && weeksBack > 0) {
                // When comparing multiple weeks, include date in label
                labelFormat = (date) => {
                    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    const timeStr = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                    return `${dateStr} ${timeStr}`;
                };
            } else {
                labelFormat = (date) => date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            }
            groupingFunction = (date) => {
                const d = new Date(date);
                d.setMinutes(0, 0, 0);
                return d.getTime();
            };
            incrementFunction = (date) => {
                date.setHours(date.getHours() + 1);
            };
            xAxisLabel = 'Hour';
            // Set start to beginning of hour
            startTime.setMinutes(0, 0, 0);
        } else if (actualGranularity === 'day') {
            labelFormat = (date) => date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            groupingFunction = (date) => {
                const d = new Date(date);
                d.setHours(0, 0, 0, 0);
                return d.getTime();
            };
            incrementFunction = (date) => {
                date.setDate(date.getDate() + 1);
            };
            xAxisLabel = 'Day';
            // Set start to beginning of day
            startTime.setHours(0, 0, 0, 0);
        } else if (actualGranularity === 'week') {
            labelFormat = (date) => {
                const weekStart = new Date(date);
                weekStart.setHours(0, 0, 0, 0);
                const day = weekStart.getDay();
                weekStart.setDate(weekStart.getDate() - day);
                return `Week of ${weekStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
            };
            groupingFunction = (date) => {
                const d = new Date(date);
                d.setHours(0, 0, 0, 0);
                const day = d.getDay();
                d.setDate(d.getDate() - day);
                return d.getTime();
            };
            incrementFunction = (date) => {
                date.setDate(date.getDate() + 7);
            };
            xAxisLabel = 'Week';
            // Set start to beginning of week
            const day = startTime.getDay();
            startTime.setDate(startTime.getDate() - day);
            startTime.setHours(0, 0, 0, 0);
        } else if (actualGranularity === 'month') {
            labelFormat = (date) => date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
            groupingFunction = (date) => {
                const d = new Date(date);
                d.setDate(1);
                d.setHours(0, 0, 0, 0);
                return d.getTime();
            };
            incrementFunction = (date) => {
                date.setMonth(date.getMonth() + 1);
            };
            xAxisLabel = 'Month';
            // Set start to beginning of month
            startTime.setDate(1);
            startTime.setHours(0, 0, 0, 0);
        }

        // Initialize all time periods with 0
        const currentPeriod = new Date(startTime);
        const allPeriods = [];
        
        // Special handling for multi-week comparison - only include matching weekdays
        if (timelineFilter === 'custom' && customDate && weeksBack > 0) {
            // Only create periods for the specific target dates
            for (let i = 0; i <= weeksBack; i++) {
                const targetDate = new Date(customDate);
                targetDate.setDate(targetDate.getDate() - (i * 7));
                targetDate.setHours(0, 0, 0, 0);
                
                // Create hourly periods for this specific date
                for (let hour = 0; hour < 24; hour++) {
                    const periodDate = new Date(targetDate);
                    periodDate.setHours(hour, 0, 0, 0);
                    const key = groupingFunction(periodDate);
                    groupedData[key] = {};
                    allPeriods.push(key);
                }
            }
        } else {
            // Normal behavior - create all periods in range
            while (currentPeriod <= endTime) {
                const key = groupingFunction(currentPeriod);
                groupedData[key] = {};
                allPeriods.push(key);
                incrementFunction(currentPeriod);
            }
        }

        // Group visits by time period AND bin
        filteredVisits.forEach(visit => {
            const key = groupingFunction(visit.endTime);
            if (groupedData.hasOwnProperty(key)) {
                if (!groupedData[key][visit.mac]) {
                    groupedData[key][visit.mac] = 0;
                }
                groupedData[key][visit.mac]++;
            }
        });

        // Create arrays in chronological order
        const sortedKeys = allPeriods.sort((a, b) => a - b);
        const labels = sortedKeys.map(key => labelFormat(new Date(key)));

        // Always create a dataset for each bin (stacked chart)
        let datasets = [];
        const binsToShow = selectedBins.includes('all') 
            ? Array.from(getBinStats().keys()) 
            : selectedBins;

        binsToShow.forEach(mac => {
            const binData = getBinStats().get(mac);
            if (!binData) return;

            const color = binColorMap.get(mac) || '#007aff';
            const data = sortedKeys.map(key => groupedData[key][mac] || 0);

            datasets.push({
                label: binData.name,
                data: data,
                backgroundColor: color + 'CC', // Add alpha for transparency
                borderColor: color,
                borderWidth: 1,
                borderRadius: 4
            });
        });

        // Calculate statistics
        const totalVisits = filteredVisits.length;
        const avgVisitsPerPeriod = sortedKeys.length > 0 ? (totalVisits / sortedKeys.length).toFixed(1) : 0;
        
        // Calculate max - sum of all bins in a period for stacked chart
        let maxVisits = 0;
        sortedKeys.forEach((key, index) => {
            const periodTotal = datasets.reduce((sum, dataset) => sum + dataset.data[index], 0);
            maxVisits = Math.max(maxVisits, periodTotal);
        });
        
        const totalDetections = filteredVisits.reduce((sum, v) => sum + v.detectionCount, 0);
        
        // Calculate periods with visits
        let periodsWithVisits = 0;
        sortedKeys.forEach((key, index) => {
            const periodTotal = datasets.reduce((sum, dataset) => sum + dataset.data[index], 0);
            if (periodTotal > 0) periodsWithVisits++;
        });

        // Chart statistics removed per user request
        document.getElementById('chartStats').innerHTML = '';

        // Create the chart
        const ctx = document.getElementById('timelineChart');
        timelineChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                const value = context.parsed.y;
                                return `${label}: ${value} visit${value !== 1 ? 's' : ''}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        stacked: true,
                        ticks: {
                            stepSize: 1,
                            precision: 0
                        },
                        title: {
                            display: true,
                            text: 'Number of Visits'
                        }
                    },
                    x: {
                        stacked: true,
                        title: {
                            display: true,
                            text: xAxisLabel
                        },
                        ticks: {
                            maxRotation: 45,
                            minRotation: 45
                        }
                    }
                }
            }
        });
    }

    function displayTimeline() {
        let filteredVisits = [...aggregatedVisits];
        
        const now = new Date();
        if (timelineFilter === 'today') {
            const todayStart = new Date(now);
            todayStart.setHours(0, 0, 0, 0);
            filteredVisits = filteredVisits.filter(v => v.endTime >= todayStart);
        } else if (timelineFilter === 'week') {
            const weekAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
            filteredVisits = filteredVisits.filter(v => v.endTime >= weekAgo);
        } else if (timelineFilter === 'month') {
            const monthAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
            filteredVisits = filteredVisits.filter(v => v.endTime >= monthAgo);
        } else if (timelineFilter === 'custom' && customDate) {
            // Filter to selected date(s)
            if (weeksBack === 0) {
                // Just the selected date
                const dayStart = new Date(customDate);
                dayStart.setHours(0, 0, 0, 0);
                const dayEnd = new Date(customDate);
                dayEnd.setHours(23, 59, 59, 999);
                filteredVisits = filteredVisits.filter(v => v.endTime >= dayStart && v.endTime <= dayEnd);
            } else {
                // Selected date plus previous weeks of same weekday
                const targetDates = [];
                for (let i = 0; i <= weeksBack; i++) {
                    const date = new Date(customDate);
                    date.setDate(date.getDate() - (i * 7));
                    targetDates.push(date.toDateString());
                }
                filteredVisits = filteredVisits.filter(v => {
                    return targetDates.includes(v.endTime.toDateString());
                });
            }
        }

        // Create the chart
        createTimelineChart(filteredVisits);

        // Filter by selected bins for the list too
        const isBinFiltered = selectedBins.length > 0 && !selectedBins.includes('all');
        if (isBinFiltered) {
            filteredVisits = filteredVisits.filter(v => selectedBins.includes(v.mac));
        }

        const timeline = document.getElementById('timeline');
        
        if (filteredVisits.length === 0) {
            let message = 'No visits found';
            if (timelineFilter !== 'all') {
                message += ' in selected time period';
            }
            if (isBinFiltered) {
                message += ' for selected bins';
            }
            timeline.innerHTML = `<div style="text-align: center; padding: 40px; color: #666;">${message}</div>`;
            return;
        }

        timeline.innerHTML = filteredVisits.map(visit => {
            const isAggregated = visit.detectionCount > 1;
            const binColor = binColorMap.get(visit.mac) || '#007aff';
            
            // Format date as DD/MM/YYYY
            const day = visit.endTime.getDate().toString().padStart(2, '0');
            const month = (visit.endTime.getMonth() + 1).toString().padStart(2, '0');
            const year = visit.endTime.getFullYear();
            const dateStr = `${day}/${month}/${year}`;
            
            return `
                <div class="timeline-event ${isAggregated ? 'aggregated' : ''}" style="border-left-color: ${binColor}">
                    <div class="timeline-time-col">
                        <div class="timeline-time">${visit.endTime.toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit', second: '2-digit' })}</div>
                        <div class="timeline-date">${dateStr}</div>
                    </div>
                    <div class="timeline-content">
                        <div class="timeline-bin-name">
                            <span style="display: inline-block; width: 10px; height: 10px; border-radius: 2px; background-color: ${binColor}; margin-right: 6px;"></span>
                            ${visit.name}
                        </div>
                        <div class="timeline-details">
                            ${visit.binSize} • ${visit.wasteType} • Signal: ${visit.avgRSSI} dBm (${visit.avgQuality})
                        </div>
                        <div class="timeline-details" style="font-size: 0.8em; margin-top: 4px;">
                            MAC: ${visit.mac}
                        </div>
                        ${isAggregated ? `
                            <div class="timeline-duration">
                                📍 Visit duration: ${visit.durationFormatted} (${visit.detectionCount} detections)
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join('');
    }

    function displayCalendar() {
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();

        document.getElementById('calendarTitle').textContent =
            currentDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });

        const firstDay = new Date(year, month, 1);
        const startDate = new Date(firstDay);
        startDate.setDate(startDate.getDate() - startDate.getDay());

        const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        let html = '<div class="month-grid">';

        days.forEach(day => {
            html += `<div class="day-header">${day}</div>`;
        });

        for (let i = 0; i < 42; i++) {
            const currentDay = new Date(startDate);
            currentDay.setDate(startDate.getDate() + i);

            const isOtherMonth = currentDay.getMonth() !== month;
            const dayVisits = aggregatedVisits.filter(v =>
                v.endTime.toDateString() === currentDay.toDateString()
            );

            const dayStr = currentDay.toISOString().split('T')[0];
            html += `<div class="day-cell ${isOtherMonth ? 'other-month' : ''}" onclick="viewDayInTimeline('${dayStr}')">
                <div class="day-number">${currentDay.getDate()}</div>`;

            if (dayVisits.length > 0) {
                html += `<div class="day-count">${dayVisits.length}</div>`;
            }

            html += `</div>`;
        }

        html += '</div>';
        document.getElementById('calendarContent').innerHTML = html;
    }

    function viewDayInTimeline(dateString) {
        // Switch to timeline view
        currentView = 'timeline';
        document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
        document.querySelector('[data-view="timeline"]').classList.add('active');
        
        // Set custom date
        customDate = new Date(dateString + 'T00:00:00');
        timelineFilter = 'custom';
        timelineGranularity = 'hour'; // Force hourly view for single days
        weeksBack = 0; // Reset to single day view
        
        // Update UI
        document.getElementById('timelineFilter').value = 'custom';
        document.getElementById('customDatePicker').value = dateString;
        
        // Show the date picker group and weeks back group
        document.getElementById('datepickerGroup').style.display = 'flex';
        document.getElementById('weeksBackGroup').style.display = 'flex';
        
        // Reset weeks back buttons
        document.querySelectorAll('[data-weeks-back]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.weeksBack === '0');
        });
        
        // Update granularity buttons
        document.querySelectorAll('.granularity-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.granularity === 'hour');
        });
        
        // Display the timeline view
        displayCurrentView();
    }

    function updateLastUpdated() {
        const now = new Date();
        const day = now.getDate().toString().padStart(2, '0');
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const year = now.getFullYear();
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        const dateTimeStr = `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
        
        const textElement = document.getElementById('lastUpdatedText');
        if (textElement) {
            textElement.textContent = `Last updated: ${dateTimeStr} • Auto-refresh: 30s`;
        }
    }

    function manualRefresh() {
        loadData(true);
    }

    function exportToCSV() {
        let dataToExport = [];
        let filename = '';

        if (currentView === 'dashboard') {
            let binStats = Array.from(getBinStats().entries()).map(([mac, data]) => ({
                'Bin Name': data.name,
                'MAC Address': mac,
                'Bin Size': data.binSize,
                'Waste Type': data.wasteType,
                'Total Visits': data.visits.length,
                'Total Detections': data.totalDetections,
                'Avg Visit Duration': formatDuration(data.visits.reduce((sum, v) => sum + v.durationMs, 0) / data.visits.length),
                'Last Seen': data.lastSeen ? formatDateTime(data.lastSeen) : 'N/A',
                'Avg Signal (dBm)': data.avgRSSI,
                'Signal Quality': data.avgQuality
            }));

            dataToExport = binStats;
            const now = new Date();
            const dateStr = `${now.getDate().toString().padStart(2, '0')}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getFullYear()}`;
            filename = `binspy-rfid-summary-${dateStr}.csv`;

        } else if (currentView === 'timeline') {
            let filteredVisits = [...aggregatedVisits];
            
            const now = new Date();
            if (timelineFilter === 'today') {
                const todayStart = new Date(now);
                todayStart.setHours(0, 0, 0, 0);
                filteredVisits = filteredVisits.filter(v => v.endTime >= todayStart);
            } else if (timelineFilter === 'week') {
                const weekAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
                filteredVisits = filteredVisits.filter(v => v.endTime >= weekAgo);
            } else if (timelineFilter === 'month') {
                const monthAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
                filteredVisits = filteredVisits.filter(v => v.endTime >= monthAgo);
            } else if (timelineFilter === 'custom' && customDate) {
                const dayStart = new Date(customDate);
                dayStart.setHours(0, 0, 0, 0);
                const dayEnd = new Date(customDate);
                dayEnd.setHours(23, 59, 59, 999);
                filteredVisits = filteredVisits.filter(v => v.endTime >= dayStart && v.endTime <= dayEnd);
            }

            dataToExport = filteredVisits.map(v => ({
                'Visit Start': formatDateTime(v.startTime),
                'Visit End': formatDateTime(v.endTime),
                'Duration': v.durationFormatted,
                'Detection Count': v.detectionCount,
                'Bin Name': v.name,
                'MAC Address': v.mac,
                'Bin Size': v.binSize,
                'Waste Type': v.wasteType,
                'Avg Signal (dBm)': v.avgRSSI,
                'Quality': v.avgQuality
            }));

            const dateStr = `${now.getDate().toString().padStart(2, '0')}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getFullYear()}`;
            filename = `binspy-rfid-visits-${timelineFilter}-${dateStr}.csv`;

        } else if (currentView === 'calendar') {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const monthVisits = aggregatedVisits.filter(v =>
                v.endTime.getFullYear() === year &&
                v.endTime.getMonth() === month
            );

            dataToExport = monthVisits.map(v => ({
                'Visit Start': formatDateTime(v.startTime),
                'Visit End': formatDateTime(v.endTime),
                'Duration': v.durationFormatted,
                'Detection Count': v.detectionCount,
                'Bin Name': v.name,
                'MAC Address': v.mac,
                'Bin Size': v.binSize,
                'Waste Type': v.wasteType,
                'Avg Signal (dBm)': v.avgRSSI,
                'Quality': v.avgQuality
            }));

            const monthName = currentDate.toLocaleDateString('en-US', { month: 'long' });
            filename = `binspy-rfid-${monthName}-${year}.csv`;
        }

        if (dataToExport.length === 0) {
            alert('No data to export');
            return;
        }

        const csv = Papa.unparse(dataToExport);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);

        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    document.addEventListener('DOMContentLoaded', () => {
        loadData(false);

        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentView = btn.dataset.view;
                displayCurrentView();
            });
        });

        document.getElementById('searchBox').addEventListener('input', (e) => {
            searchTerm = e.target.value;
            displayBins();
        });

        // Toggle detections button
        document.getElementById('toggleDetectionsBtn').addEventListener('click', (e) => {
            showDetectionCount = !showDetectionCount;
            const btn = e.currentTarget;
            
            if (showDetectionCount) {
                btn.classList.add('active');
                btn.textContent = 'Show Detections';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Hide Detections';
            }
            
            displayBins();
        });

        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('filter-btn')) {
                const filterType = e.target.dataset.filterType;
                const filterValue = e.target.dataset.filter;
                
                if (filterType === 'waste') {
                    document.querySelectorAll('[data-filter-type="waste"]').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    e.target.classList.add('active');
                    wasteTypeFilter = filterValue;
                } else if (filterType === 'size') {
                    document.querySelectorAll('[data-filter-type="size"]').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    e.target.classList.add('active');
                    binSizeFilter = filterValue;
                }
                
                displayBins();
            }
        });

        document.getElementById('timelineFilter').addEventListener('change', (e) => {
            timelineFilter = e.target.value;
            
            // Show/hide date picker and weeks back
            const datepickerGroup = document.getElementById('datepickerGroup');
            const weeksBackGroup = document.getElementById('weeksBackGroup');
            if (timelineFilter === 'custom') {
                datepickerGroup.style.display = 'flex';
                weeksBackGroup.style.display = 'flex';
                // Set date picker to today if no date selected
                if (!customDate) {
                    const today = new Date();
                    const dateStr = today.toISOString().split('T')[0];
                    document.getElementById('customDatePicker').value = dateStr;
                    customDate = today;
                }
                // Auto switch to hourly view for custom dates
                timelineGranularity = 'hour';
                document.querySelectorAll('.granularity-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.granularity === 'hour');
                });
            } else {
                datepickerGroup.style.display = 'none';
                weeksBackGroup.style.display = 'none';
                customDate = null;
                weeksBack = 0;
                // Reset weeks back buttons
                document.querySelectorAll('[data-weeks-back]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.weeksBack === '0');
                });
            }
            
            displayTimeline();
        });

        // Custom date picker change event
        document.getElementById('customDatePicker').addEventListener('change', (e) => {
            const dateStr = e.target.value;
            if (dateStr) {
                customDate = new Date(dateStr + 'T00:00:00');
                displayTimeline();
            }
        });

        // Clear date button
        document.getElementById('clearDateBtn').addEventListener('click', () => {
            customDate = null;
            weeksBack = 0;
            timelineFilter = 'week';
            document.getElementById('timelineFilter').value = 'week';
            document.getElementById('datepickerGroup').style.display = 'none';
            document.getElementById('weeksBackGroup').style.display = 'none';
            
            // Reset weeks back buttons
            document.querySelectorAll('[data-weeks-back]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.weeksBack === '0');
            });
            
            // Update mobile buttons
            document.querySelectorAll('.mobile-time-buttons .filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.timeFilter === 'week');
            });
            
            displayTimeline();
        });

        // Weeks back buttons event listener
        document.querySelectorAll('[data-weeks-back]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const weeks = parseInt(e.target.dataset.weeksBack);
                
                // Update button states
                document.querySelectorAll('[data-weeks-back]').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                
                // Update weeks back value
                weeksBack = weeks;
                
                displayTimeline();
            });
        });

        // Mobile time range buttons event listener
        document.querySelectorAll('.mobile-time-buttons .filter-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const timeValue = e.target.dataset.timeFilter;
                
                // Update button states
                document.querySelectorAll('.mobile-time-buttons .filter-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                
                // Update dropdown (for when switching back to desktop)
                document.getElementById('timelineFilter').value = timeValue;
                
                // Update filter and refresh
                timelineFilter = timeValue;
                
                // Show/hide date picker and weeks back for mobile too
                const datepickerGroup = document.getElementById('datepickerGroup');
                const weeksBackGroup = document.getElementById('weeksBackGroup');
                if (timelineFilter === 'custom') {
                    datepickerGroup.style.display = 'flex';
                    weeksBackGroup.style.display = 'flex';
                    if (!customDate) {
                        const today = new Date();
                        const dateStr = today.toISOString().split('T')[0];
                        document.getElementById('customDatePicker').value = dateStr;
                        customDate = today;
                    }
                    timelineGranularity = 'hour';
                    document.querySelectorAll('.granularity-btn').forEach(b => {
                        b.classList.toggle('active', b.dataset.granularity === 'hour');
                    });
                } else {
                    datepickerGroup.style.display = 'none';
                    weeksBackGroup.style.display = 'none';
                    customDate = null;
                    weeksBack = 0;
                    // Reset weeks back buttons
                    document.querySelectorAll('[data-weeks-back]').forEach(b => {
                        b.classList.toggle('active', b.dataset.weeksBack === '0');
                    });
                }
                
                displayTimeline();
            });
        });

        // Granularity buttons event listener
        document.querySelectorAll('.granularity-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.granularity-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                timelineGranularity = e.target.dataset.granularity;
                displayTimeline();
            });
        });

        // Clear filters button
        document.getElementById('clearFiltersBtn').addEventListener('click', () => {
            selectedBins = ['all'];
            
            // Uncheck all individual bins
            const container = document.getElementById('binCheckboxContainer');
            if (container) {
                container.querySelectorAll('input[type="checkbox"]:not(#checkbox-all)').forEach(cb => {
                    cb.checked = false;
                    cb.closest('.bin-checkbox-item').classList.remove('checked');
                });
                
                // Check "All Bins"
                const allCheckbox = document.getElementById('checkbox-all');
                if (allCheckbox) {
                    allCheckbox.checked = true;
                    document.getElementById('binCheckAll').classList.add('checked');
                }
            }
            
            document.getElementById('clearFiltersBtn').style.display = 'none';
            updateSelectedBinsDisplay();
            displayTimeline();
        });

        document.getElementById('prevBtn').addEventListener('click', () => {
            currentDate.setMonth(currentDate.getMonth() - 1);
            displayCalendar();
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            currentDate.setMonth(currentDate.getMonth() + 1);
            displayCalendar();
        });

        document.getElementById('todayBtn').addEventListener('click', () => {
            currentDate = new Date();
            displayCalendar();
        });
    });

    // Auto-refresh every 30 seconds
    setInterval(() => {
        loadData(true);
        updateHeartbeatDisplay();
    }, 30000);

    // Update heartbeat display every 5 seconds
    setInterval(() => {
        updateHeartbeatDisplay();
    }, 5000);
</script>
</body>
</html>
