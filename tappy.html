<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR TAP ATTACK - Neural Hand Training</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --cyber-bg: #0a0a0a;
            --cyber-surface: #1a1a1a;
            --cyber-border: #333333;
            --cyber-primary: #666666;
            --cyber-purple: #9333ea;
            --cyber-silver: #e2e8f0;
            --cyber-text: #cccccc;
            --cyber-dim: #888888;
            --cyber-danger: #666666;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--cyber-bg);
            color: var(--cyber-text);
            overflow: hidden;
            position: relative;
            height: 100vh;
            width: 100vw;
        }

        /* Animated background grid */
        .bg-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(var(--cyber-border) 1px, transparent 1px),
                linear-gradient(90deg, var(--cyber-border) 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0.3;
            z-index: 0;
            animation: gridMove 20s linear infinite;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Scanline effect */
        .scanline {
            display: none;
        }

        /* Video container */
        #videoContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--cyber-bg);
        }

        #cameraFeed {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
            transform: scaleX(-1);
        }

        #cameraFeed.rear-camera {
            transform: scaleX(1);
        }

        /* Main container */
        .container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .container > * {
            pointer-events: auto;
        }

        /* Menu overlay */
        .menu-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid var(--cyber-border);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            padding: 1.5rem;
            animation: menuAppear 0.5s ease-out;
            overflow-y: auto;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .menu-overlay {
                padding: 1rem;
                max-height: 95vh;
            }
        }

        @keyframes menuAppear {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .menu-header {
            text-align: center;
            margin-bottom: 1rem;
            position: relative;
        }

        .menu-logo {
            max-width: 150px;
            height: auto;
            margin: 0 auto 0.5rem;
            display: block;
        }

        .menu-title {
            font-size: clamp(1.25rem, 4vw, 2rem);
            font-weight: 700;
            letter-spacing: 0.1em;
            color: var(--cyber-text);
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }

        .menu-subtitle {
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.75rem;
            color: var(--cyber-dim);
            letter-spacing: 0.15em;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .menu-logo {
                max-width: 120px;
                margin-bottom: 0.25rem;
            }
            
            .menu-title {
                font-size: 1.25rem;
                margin-bottom: 0.25rem;
            }
            
            .menu-subtitle {
                font-size: 0.7rem;
            }
            
            .menu-header {
                margin-bottom: 0.75rem;
            }
        }

        .menu-subtitle {
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9rem;
            color: var(--cyber-dim);
            letter-spacing: 0.15em;
        }

        /* Form elements */
        .form-group {
            margin-bottom: 1rem;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .form-group {
                margin-bottom: 0.75rem;
            }
        }

        .menu-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }

        @media (orientation: landscape) and (min-width: 768px) {
            .menu-content {
                grid-template-columns: 1fr 1fr;
                gap: 1.5rem;
            }
            
            .menu-content .form-group:first-child,
            .menu-content .instructions,
            .menu-content .ai-analysis {
                grid-column: 1 / -1;
            }
        }

        .form-label {
            display: block;
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            color: var(--cyber-text);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }

        .form-input {
            width: 100%;
            padding: 0.65rem 0.85rem;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--cyber-border);
            color: var(--cyber-text);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .form-label {
                font-size: 0.75rem;
                margin-bottom: 0.35rem;
            }
            
            .form-input {
                padding: 0.5rem 0.75rem;
                font-size: 0.9rem;
            }
        }

        .form-input:focus {
            outline: none;
            border-color: var(--cyber-primary);
            box-shadow: 0 0 10px rgba(102, 102, 102, 0.3);
            background: rgba(0, 0, 0, 0.6);
        }

        /* Radio buttons */
        .radio-group {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }

        .radio-option {
            position: relative;
        }

        .radio-option input {
            position: absolute;
            opacity: 0;
        }

        .radio-label {
            display: block;
            padding: 0.65rem 0.5rem;
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--cyber-border);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 0.85rem;
            letter-spacing: 0.05em;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .radio-label {
                padding: 0.5rem 0.35rem;
                font-size: 0.8rem;
            }
        }

        .radio-option input:checked + .radio-label {
            background: rgba(102, 102, 102, 0.3);
            border-color: var(--cyber-primary);
            color: var(--cyber-text);
            box-shadow: 0 0 10px rgba(102, 102, 102, 0.3);
        }

        .radio-label:hover {
            border-color: var(--cyber-primary);
        }

        /* Stats grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        @media (orientation: landscape) and (min-width: 568px) {
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 1rem;
            }
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--cyber-border);
            padding: 0.75rem;
            text-align: center;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .stat-card {
                padding: 0.5rem;
            }
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--cyber-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--cyber-text);
            font-family: 'Share Tech Mono', monospace;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 0.85rem;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .btn {
                padding: 0.65rem;
                font-size: 0.9rem;
            }
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: var(--cyber-text);
            color: #000;
            margin-bottom: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .btn-primary {
                margin-bottom: 0.35rem;
            }
        }

        .btn-primary:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
            background: #ffffff;
        }

        .btn-secondary {
            background: rgba(0, 0, 0, 0.3);
            color: var(--cyber-text);
            border: 1px solid var(--cyber-border);
        }

        .btn-secondary:hover {
            border-color: var(--cyber-primary);
            color: var(--cyber-text);
            background: rgba(0, 0, 0, 0.5);
        }

        /* Instructions */
        .instructions {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--cyber-border);
            padding: 0.85rem;
            margin-bottom: 1rem;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .instructions {
                padding: 0.65rem;
                margin-bottom: 0.75rem;
                font-size: 0.8rem;
                line-height: 1.4;
            }
        }

        .instructions-title {
            font-weight: 600;
            color: var(--cyber-text);
            margin-bottom: 0.4rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.85rem;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .instructions-title {
                font-size: 0.8rem;
                margin-bottom: 0.3rem;
            }
        }

        .instructions-list {
            list-style: none;
            padding-left: 0;
        }

        .instructions-list li {
            padding-left: 1.25rem;
            position: relative;
            margin-bottom: 0.2rem;
        }

        .instructions-list li::before {
            content: '▸';
            position: absolute;
            left: 0;
            color: var(--cyber-primary);
        }

        /* Device controls */
        .device-controls {
            position: fixed;
            top: 0.75rem;
            right: 0.75rem;
            display: flex;
            gap: 0.4rem;
            z-index: 100;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .device-controls {
                top: 0.5rem;
                right: 0.5rem;
                gap: 0.3rem;
            }
        }

        .icon-btn {
            width: 44px;
            height: 44px;
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid var(--cyber-border);
            color: var(--cyber-text);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            padding: 0;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .icon-btn {
                width: 38px;
                height: 38px;
            }
        }

        .icon-btn svg {
            width: 22px;
            height: 22px;
            fill: var(--cyber-text);
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .icon-btn svg {
                width: 20px;
                height: 20px;
            }
        }

        .icon-btn:hover {
            background: rgba(102, 102, 102, 0.2);
            border-color: var(--cyber-primary);
        }

        .icon-btn:hover svg {
            fill: #ffffff;
        }

        .icon-btn.active {
            background: rgba(102, 102, 102, 0.3);
            border-color: var(--cyber-primary);
        }

        /* Game state */
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
            transform: scaleX(-1);
        }

        #gameCanvas.rear-camera {
            transform: scaleX(1);
        }

        /* Target styling */
        .target {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
            z-index: 50;
            animation: targetAppear 0.3s ease-out;
            pointer-events: none;
            box-shadow: 0 0 30px currentColor;
            transform: scaleX(-1);
        }

        .target.rear-camera {
            transform: scaleX(1);
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .target {
                width: 42px;
                height: 42px;
                font-size: 0.8rem;
            }
        }

        .target::before {
            content: '';
            position: absolute;
            inset: -5px;
            border: 2px dashed currentColor;
            border-radius: 50%;
            animation: targetRotate 4s linear infinite;
        }

        .target::after {
            content: '';
            position: absolute;
            inset: 0;
            border: 2px solid currentColor;
            border-radius: 50%;
            opacity: 0.3;
        }

        @keyframes targetAppear {
            from {
                transform: scale(0);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes targetRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .target-left {
            background: radial-gradient(circle, rgba(226, 232, 240, 0.9), rgba(226, 232, 240, 0.5) 70%);
            border: 3px solid var(--cyber-silver);
            color: var(--cyber-silver);
        }

        .target-right {
            background: radial-gradient(circle, rgba(147, 51, 234, 0.9), rgba(147, 51, 234, 0.5) 70%);
            border: 3px solid var(--cyber-purple);
            color: var(--cyber-purple);
        }

        .target-timer {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .target-timer-bar {
            height: 100%;
            background: var(--cyber-cyan);
            width: 100%;
            animation: timerDrain linear;
        }

        @keyframes timerDrain {
            from { width: 100%; }
            to { width: 0%; }
        }

        /* Countdown */
        .countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            font-weight: 700;
            color: var(--cyber-text);
            z-index: 200;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: countdownPulse 1s ease-in-out;
            font-family: 'Share Tech Mono', monospace;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .countdown {
                font-size: 5rem;
            }
        }

        @keyframes countdownPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.7; }
        }

        /* Game HUD */
        .game-hud {
            position: fixed;
            top: 0.75rem;
            left: 0.75rem;
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid var(--cyber-border);
            padding: 0.75rem;
            z-index: 100;
            min-width: 160px;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .game-hud {
                top: 0.5rem;
                left: 0.5rem;
                padding: 0.5rem 0.65rem;
                min-width: 140px;
            }
        }

        .hud-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.4rem;
            font-size: 0.85rem;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .hud-item {
                margin-bottom: 0.3rem;
                font-size: 0.8rem;
            }
            
            .hud-item:last-child {
                margin-bottom: 0;
            }
        }

        .hud-label {
            color: var(--cyber-dim);
            text-transform: uppercase;
            font-size: 0.7rem;
            letter-spacing: 0.05em;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .hud-label {
                font-size: 0.65rem;
            }
        }

        .hud-value {
            color: var(--cyber-text);
            font-family: 'Share Tech Mono', monospace;
            font-weight: 700;
        }

        /* Stop button */
        .stop-btn {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.85rem 1.75rem;
            background: var(--cyber-primary);
            color: #fff;
            border: none;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            font-size: 0.95rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .stop-btn {
                bottom: 0.75rem;
                padding: 0.65rem 1.25rem;
                font-size: 0.85rem;
            }
        }

        .stop-btn:hover {
            background: #888888;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateX(-50%) scale(1.05);
        }

        /* AI Analysis */
        .ai-analysis {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--cyber-border);
            padding: 0.85rem;
            margin-bottom: 1rem;
            animation: analysisAppear 0.5s ease-out;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .ai-analysis {
                padding: 0.65rem;
                margin-bottom: 0.75rem;
            }
        }

        @keyframes analysisAppear {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .ai-analysis-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.65rem;
            color: var(--cyber-text);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.05em;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .ai-analysis-header {
                font-size: 0.75rem;
                margin-bottom: 0.5rem;
            }
        }

        .ai-analysis-icon {
            width: 16px;
            height: 16px;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .ai-analysis-icon {
                width: 14px;
                height: 14px;
            }
        }

        .ai-analysis-icon svg {
            fill: var(--cyber-text);
        }

        .ai-analysis-text {
            line-height: 1.5;
            font-size: 0.9rem;
            color: var(--cyber-text);
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .ai-analysis-text {
                font-size: 0.85rem;
                line-height: 1.4;
            }
        }

        /* Loading state */
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--cyber-primary);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .target-timer-bar {
            height: 100%;
            background: var(--cyber-text);
            width: 100%;
            animation: timerDrain linear;
        }

        /* Hidden class */
        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 640px) and (orientation: portrait) {
            .menu-overlay {
                width: 95%;
                padding: 1.5rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }
        }

        /* Touch-friendly adjustments */
        @media (hover: none) and (pointer: coarse) {
            .icon-btn,
            .btn,
            .radio-label {
                -webkit-tap-highlight-color: transparent;
                touch-action: manipulation;
            }
        }
    </style>
</head>
<body>
    <div class="bg-grid"></div>
    <div class="scanline"></div>

    <!-- Video container -->
    <div id="videoContainer">
        <video id="cameraFeed" autoplay playsinline></video>
    </div>

    <!-- Game canvas for hand tracking visualization -->
    <canvas id="gameCanvas"></canvas>

    <!-- Device controls -->
    <div class="device-controls">
        <button class="icon-btn" id="fullscreenBtn" title="Toggle Fullscreen">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
            </svg>
        </button>
        <button class="icon-btn" id="cameraToggleBtn" title="Switch Camera">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-8 3c1.63 0 3.06.79 3.98 2H12c-1.66 0-3 1.34-3 3 0 .35.07.69.18 1H7.1c-.06-.32-.1-.66-.1-1 0-2.76 2.24-5 5-5zm0 10c-1.63 0-3.06-.79-3.98-2H12c1.66 0 3-1.34 3-3 0-.35-.07-.69-.18-1h2.08c.07.32.1.66.1 1 0 2.76-2.24 5-5 5z"/>
            </svg>
        </button>
        <button class="icon-btn" id="videoToggleBtn" title="Toggle Video">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
            </svg>
        </button>
    </div>

    <div class="container">
        <!-- Main Menu -->
        <div id="mainMenu" class="menu-overlay">
            <div class="menu-header">
                <img src="https://i.imgur.com/kG2dDb7.png" alt="Logo" class="menu-logo">
                <h1 class="menu-title">AR TAP ATTACK</h1>
                <p class="menu-subtitle">Neural Hand Training System</p>
            </div>

            <!-- AI Analysis (shown after game) -->
            <div id="aiAnalysisContainer" class="ai-analysis hidden">
                <div class="ai-analysis-header">
                    <span class="ai-analysis-icon">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-3 12h-2v-2h2v2zm0-4h-2V6h2v4z"/>
                        </svg>
                    </span>
                    <span>PERFORMANCE ANALYSIS</span>
                </div>
                <div class="ai-analysis-text" id="aiAnalysisText">Analyzing performance...</div>
            </div>

            <!-- Player Name -->
            <div class="form-group">
                <label class="form-label" for="playerName">Operator ID</label>
                <input type="text" id="playerName" class="form-input" placeholder="Enter your name" value="">
            </div>

            <!-- Difficulty Selection -->
            <div class="form-group">
                <label class="form-label">Training Mode</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="diffEasy" name="difficulty" value="easy">
                        <label for="diffEasy" class="radio-label">EASY</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="diffMedium" name="difficulty" value="medium" checked>
                        <label for="diffMedium" class="radio-label">MEDIUM</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="diffHard" name="difficulty" value="hard">
                        <label for="diffHard" class="radio-label">HARD</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="diffPro" name="difficulty" value="pro">
                        <label for="diffPro" class="radio-label">PRO</label>
                    </div>
                </div>
            </div>

            <!-- Stats Grid -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Last Avg</div>
                    <div class="stat-value" id="lastTime">---</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Best Single</div>
                    <div class="stat-value" id="bestSingle">---</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Best Avg</div>
                    <div class="stat-value" id="bestAvg">---</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Last Acc</div>
                    <div class="stat-value" id="accuracy">---</div>
                </div>
            </div>

            <!-- Instructions -->
            <div class="instructions">
                <div class="instructions-title">Mission Briefing</div>
                <ul class="instructions-list">
                    <li><strong style="color: var(--cyber-silver)">SILVER</strong> targets → Use hand on LEFT side of screen</li>
                    <li><strong style="color: var(--cyber-purple)">PURPLE</strong> targets → Use hand on RIGHT side of screen</li>
                    <li>Move the crosshair in your palm directly over the target</li>
                    <li>Target will grow when you're getting close!</li>
                </ul>
            </div>

            <!-- Action Buttons -->
            <button class="btn btn-primary" id="startBtn">START TRAINING</button>
            <button class="btn btn-secondary" id="resultsBtn">PERFORMANCE RESULTS</button>
        </div>

        <!-- Game HUD (shown during game) -->
        <div id="gameHUD" class="game-hud hidden">
            <div class="hud-item">
                <span class="hud-label">Target:</span>
                <span class="hud-value" id="targetCounter">0/40</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Hits:</span>
                <span class="hud-value" id="hitCounter">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Misses:</span>
                <span class="hud-value" id="missCounter">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Avg Time:</span>
                <span class="hud-value" id="avgTime">0ms</span>
            </div>
        </div>

        <!-- Stop Button (shown during game) -->
        <button id="stopBtn" class="stop-btn hidden">ABORT MISSION</button>
    </div>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // Game state
        const gameState = {
            isPlaying: false,
            isPaused: false,
            currentTarget: null,
            targetStartTime: 0,
            hits: [],
            misses: 0,
            targetIndex: 0,
            sequence: [], // Will hold 'left' or 'right' for each target
            hands: { left: null, right: null },
            difficulty: 'medium',
            playerName: '',
            cameraFacing: 'user', // 'user' or 'environment'
            videoVisible: true,
            difficultySettings: {
                easy: { timeout: 5000, name: 'EASY' },
                medium: { timeout: 3500, name: 'MEDIUM' },
                hard: { timeout: 2500, name: 'HARD' },
                pro: { timeout: 1500, name: 'PRO' }
            }
        };

        // DOM elements
        const mainMenu = document.getElementById('mainMenu');
        const gameHUD = document.getElementById('gameHUD');
        const stopBtn = document.getElementById('stopBtn');
        const startBtn = document.getElementById('startBtn');
        const resultsBtn = document.getElementById('resultsBtn');
        const playerNameInput = document.getElementById('playerName');
        const videoContainer = document.getElementById('videoContainer');
        const cameraFeed = document.getElementById('cameraFeed');
        const gameCanvas = document.getElementById('gameCanvas');
        const canvasCtx = gameCanvas.getContext('2d');
        const aiAnalysisContainer = document.getElementById('aiAnalysisContainer');
        const aiAnalysisText = document.getElementById('aiAnalysisText');

        // Device controls
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const cameraToggleBtn = document.getElementById('cameraToggleBtn');
        const videoToggleBtn = document.getElementById('videoToggleBtn');

        // MediaPipe Hands setup
        let hands, camera;
        
        // Audio context for sound effects
        let audioContext;
        
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Web Audio API not supported');
            }
        }
        
        function playDingSound() {
            if (!audioContext) return;
            
            // Create oscillator for the ding sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Higher frequency for a pleasant "ding"
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
            
            // Volume envelope - quick attack and decay
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            // Play the sound
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        }

        // Initialize
        function init() {
            loadPlayerData();
            updateStats();
            setupEventListeners();
            setupMediaPipe();
            initAudio();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            gameCanvas.width = window.innerWidth;
            gameCanvas.height = window.innerHeight;
        }

        function setupEventListeners() {
            startBtn.addEventListener('click', startGame);
            stopBtn.addEventListener('click', stopGame);
            resultsBtn.addEventListener('click', () => {
                window.location.href = 'ar-tap-attack-results.html';
            });

            // Difficulty selection
            document.querySelectorAll('input[name="difficulty"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    gameState.difficulty = e.target.value;
                });
            });

            // Player name
            playerNameInput.addEventListener('change', (e) => {
                gameState.playerName = e.target.value.trim();
                savePlayerData();
            });

            // Device controls
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            cameraToggleBtn.addEventListener('click', toggleCamera);
            videoToggleBtn.addEventListener('click', toggleVideo);
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        async function toggleCamera() {
            gameState.cameraFacing = gameState.cameraFacing === 'user' ? 'environment' : 'user';
            
            // Update video, canvas, and target orientation (flip front camera, don't flip rear)
            if (gameState.cameraFacing === 'environment') {
                cameraFeed.classList.add('rear-camera');
                gameCanvas.classList.add('rear-camera');
                document.querySelectorAll('.target').forEach(t => t.classList.add('rear-camera'));
            } else {
                cameraFeed.classList.remove('rear-camera');
                gameCanvas.classList.remove('rear-camera');
                document.querySelectorAll('.target').forEach(t => t.classList.remove('rear-camera'));
            }
            
            await setupCamera();
        }

        function toggleVideo() {
            gameState.videoVisible = !gameState.videoVisible;
            videoContainer.style.opacity = gameState.videoVisible ? '1' : '0';
            videoToggleBtn.classList.toggle('active');
        }

        // MediaPipe setup
        async function setupMediaPipe() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);
            await setupCamera();
        }

        async function setupCamera() {
            if (camera) {
                camera.stop();
            }

            camera = new Camera(cameraFeed, {
                onFrame: async () => {
                    await hands.send({ image: cameraFeed });
                },
                facingMode: gameState.cameraFacing,
                width: 1280,
                height: 720
            });

            await camera.start();
        }

        function onHandsResults(results) {
            // Clear canvas
            canvasCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            // Get video bounds
            const bounds = getVideoBounds();

            // Update hand positions
            gameState.hands = { left: null, right: null };

            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    let handedness = results.multiHandedness[i].label.toLowerCase();
                    
                    // IMPORTANT: When front camera is mirrored, swap the hand labels
                    if (gameState.cameraFacing === 'user') {
                        handedness = handedness === 'left' ? 'right' : 'left';
                    }
                    
                    // Calculate palm center from multiple landmarks for better accuracy
                    const palmLandmarks = [
                        landmarks[0],  // Wrist
                        landmarks[5],  // Index base
                        landmarks[9],  // Middle base
                        landmarks[13], // Ring base
                        landmarks[17]  // Pinky base
                    ];
                    
                    // Get normalized coordinates (0-1) and transform to video bounds
                    const normX = palmLandmarks.reduce((sum, lm) => sum + lm.x, 0) / palmLandmarks.length;
                    const normY = palmLandmarks.reduce((sum, lm) => sum + lm.y, 0) / palmLandmarks.length;
                    
                    // Transform to actual video coordinates within canvas
                    const palmX = bounds.offsetX + (normX * bounds.width);
                    const palmY = bounds.offsetY + (normY * bounds.height);

                    gameState.hands[handedness] = { x: palmX, y: palmY };

                    // Draw hand indicator - visible circle
                    canvasCtx.fillStyle = handedness === 'left' ? 'rgba(226, 232, 240, 0.7)' : 'rgba(147, 51, 234, 0.7)';
                    canvasCtx.beginPath();
                    canvasCtx.arc(palmX, palmY, 40, 0, Math.PI * 2);
                    canvasCtx.fill();
                    
                    // Draw crosshair at detection point
                    canvasCtx.strokeStyle = '#000';
                    canvasCtx.lineWidth = 3;
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(palmX - 20, palmY);
                    canvasCtx.lineTo(palmX + 20, palmY);
                    canvasCtx.moveTo(palmX, palmY - 20);
                    canvasCtx.lineTo(palmX, palmY + 20);
                    canvasCtx.stroke();
                }
            }

            // Check for target hits
            if (gameState.isPlaying && gameState.currentTarget) {
                checkTargetHit();
            }
        }

        // Game logic
        function startGame() {
            if (!gameState.playerName) {
                playerNameInput.focus();
                playerNameInput.style.borderColor = 'var(--cyber-danger)';
                setTimeout(() => {
                    playerNameInput.style.borderColor = '';
                }, 1000);
                return;
            }

            // Resume audio context (required by some browsers)
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            gameState.difficulty = document.querySelector('input[name="difficulty"]:checked').value;
            
            // Generate sequence: 20 left, 20 right, randomized
            gameState.sequence = [];
            for (let i = 0; i < 20; i++) {
                gameState.sequence.push('left');
                gameState.sequence.push('right');
            }
            shuffleArray(gameState.sequence);

            // Reset game state
            gameState.hits = [];
            gameState.misses = 0;
            gameState.targetIndex = 0;
            gameState.currentTarget = null;

            // Hide menu, show HUD
            mainMenu.classList.add('hidden');
            gameHUD.classList.remove('hidden');
            stopBtn.classList.remove('hidden');
            aiAnalysisContainer.classList.add('hidden');

            // Start countdown
            startCountdown();
        }

        function startCountdown() {
            let count = 5;
            const countdownEl = document.createElement('div');
            countdownEl.className = 'countdown';
            countdownEl.textContent = count;
            document.body.appendChild(countdownEl);

            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.textContent = count;
                } else {
                    countdownEl.textContent = 'GO!';
                    setTimeout(() => {
                        countdownEl.remove();
                        gameState.isPlaying = true;
                        spawnTarget();
                    }, 500);
                    clearInterval(countInterval);
                }
            }, 1000);
        }

        function getVideoBounds() {
            // Get actual video dimensions and position within canvas
            const video = cameraFeed;
            const canvas = gameCanvas;
            
            const videoAspect = video.videoWidth / video.videoHeight;
            const canvasAspect = canvas.width / canvas.height;
            
            let videoWidth, videoHeight, offsetX, offsetY;
            
            if (canvasAspect > videoAspect) {
                // Canvas is wider - video will be letterboxed on sides
                videoHeight = canvas.height;
                videoWidth = videoHeight * videoAspect;
                offsetX = (canvas.width - videoWidth) / 2;
                offsetY = 0;
            } else {
                // Canvas is taller - video will be letterboxed on top/bottom
                videoWidth = canvas.width;
                videoHeight = videoWidth / videoAspect;
                offsetX = 0;
                offsetY = (canvas.height - videoHeight) / 2;
            }
            
            return { width: videoWidth, height: videoHeight, offsetX, offsetY };
        }

        function spawnTarget() {
            if (gameState.targetIndex >= 40) {
                endGame();
                return;
            }

            const handType = gameState.sequence[gameState.targetIndex];
            
            // Get actual video bounds
            const videoBounds = getVideoBounds();
            
            // Adjust margins and target size based on orientation
            const isLandscapeMobile = window.matchMedia('(orientation: landscape) and (max-height: 500px)').matches;
            const margin = isLandscapeMobile ? 80 : 120;
            const targetSize = isLandscapeMobile ? 42 : 50;
            const hitRadius = isLandscapeMobile ? 42 : 50;
            
            // Split screen horizontally - left targets on left half, right targets on right half
            const centerX = videoBounds.offsetX + (videoBounds.width / 2);
            
            let x, y;
            let attempts = 0;
            const maxAttempts = 20;
            let validPosition = false;
            
            // Try to find a position that's not too close to any hand
            while (!validPosition && attempts < maxAttempts) {
                if (handType === 'left') {
                    // Left targets: from left edge to center
                    x = videoBounds.offsetX + margin + Math.random() * ((videoBounds.width / 2) - margin * 2);
                } else {
                    // Right targets: from center to right edge
                    x = centerX + margin + Math.random() * ((videoBounds.width / 2) - margin * 2);
                }
                
                // Y can be anywhere within video bounds
                y = videoBounds.offsetY + margin + Math.random() * (videoBounds.height - margin * 2);
                
                // Calculate target center
                const targetCenterX = x + (targetSize / 2);
                const targetCenterY = y + (targetSize / 2);
                
                // Check distance from all hands
                validPosition = true;
                const minDistance = hitRadius * 2.5; // Keep targets at least 2.5x hit radius away from hands
                
                for (const hand of Object.values(gameState.hands)) {
                    if (hand) {
                        // Mirror hand X coordinate if using front camera for correct distance calculation
                        let handX = hand.x;
                        if (gameState.cameraFacing === 'user') {
                            handX = gameCanvas.width - hand.x;
                        }
                        
                        const distance = Math.sqrt(
                            Math.pow(handX - targetCenterX, 2) +
                            Math.pow(hand.y - targetCenterY, 2)
                        );
                        
                        if (distance < minDistance) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                
                attempts++;
            }
            
            // If we couldn't find a valid position after max attempts, use the last position anyway
            if (!validPosition && attempts >= maxAttempts) {
                console.log('Could not find position away from hands, spawning anyway');
            }

            const targetEl = document.createElement('div');
            targetEl.className = `target target-${handType}`;
            
            // Add rear-camera class if using rear camera
            if (gameState.cameraFacing === 'environment') {
                targetEl.classList.add('rear-camera');
            }
            
            targetEl.style.left = `${x}px`;
            targetEl.style.top = `${y}px`;

            // Add timer bar
            const timerBar = document.createElement('div');
            timerBar.className = 'target-timer';
            const timerBarFill = document.createElement('div');
            timerBarFill.className = 'target-timer-bar';
            const timeout = gameState.difficultySettings[gameState.difficulty].timeout;
            timerBarFill.style.animationDuration = `${timeout}ms`;
            timerBar.appendChild(timerBarFill);
            targetEl.appendChild(timerBar);

            document.body.appendChild(targetEl);

            gameState.currentTarget = {
                element: targetEl,
                hand: handType,
                x: x + (targetSize / 2), // Center of target
                y: y + (targetSize / 2),
                spawnTime: Date.now(),
                timeout: setTimeout(() => {
                    missTarget();
                }, timeout)
            };

            gameState.targetStartTime = Date.now();
            updateHUD();
        }

        function checkTargetHit() {
            if (!gameState.currentTarget) return;

            const target = gameState.currentTarget;
            const hand = gameState.hands[target.hand];

            if (hand) {
                // When canvas is flipped, mirror the hand X coordinate to match target coordinate system
                let handX = hand.x;
                if (gameState.cameraFacing === 'user') {
                    // Canvas is flipped, so mirror X coordinate
                    handX = gameCanvas.width - hand.x;
                }
                
                // Hit radius matches target size
                const isLandscapeMobile = window.matchMedia('(orientation: landscape) and (max-height: 500px)').matches;
                const hitRadius = isLandscapeMobile ? 42 : 50;
                
                const distance = Math.sqrt(
                    Math.pow(handX - target.x, 2) +
                    Math.pow(hand.y - target.y, 2)
                );

                // Visual feedback when close
                if (distance < hitRadius * 1.3) {
                    target.element.style.transform = target.element.classList.contains('rear-camera') ? 'scaleX(1) scale(1.15)' : 'scaleX(-1) scale(1.15)';
                    target.element.style.transition = 'transform 0.1s ease';
                } else {
                    target.element.style.transform = target.element.classList.contains('rear-camera') ? 'scaleX(1) scale(1)' : 'scaleX(-1) scale(1)';
                }

                if (distance < hitRadius) {
                    hitTarget();
                }
            }
        }

        function hitTarget() {
            const reactionTime = Date.now() - gameState.targetStartTime;
            gameState.hits.push({
                targetIndex: gameState.targetIndex,
                hand: gameState.currentTarget.hand,
                reactionTime: reactionTime,
                hit: true
            });

            // Play ding sound
            playDingSound();

            clearTimeout(gameState.currentTarget.timeout);
            gameState.currentTarget.element.remove();
            gameState.currentTarget = null;
            gameState.targetIndex++;

            updateHUD();
            setTimeout(() => spawnTarget(), 500);
        }

        function missTarget() {
            gameState.misses++;
            gameState.hits.push({
                targetIndex: gameState.targetIndex,
                hand: gameState.currentTarget.hand,
                reactionTime: null,
                hit: false
            });

            if (gameState.currentTarget) {
                gameState.currentTarget.element.remove();
                gameState.currentTarget = null;
            }
            gameState.targetIndex++;

            updateHUD();
            setTimeout(() => spawnTarget(), 500);
        }

        function updateHUD() {
            document.getElementById('targetCounter').textContent = `${gameState.targetIndex}/40`;
            document.getElementById('hitCounter').textContent = gameState.hits.filter(h => h.hit).length;
            document.getElementById('missCounter').textContent = gameState.misses;
            
            const validHits = gameState.hits.filter(h => h.hit && h.reactionTime);
            if (validHits.length > 0) {
                const avgTime = validHits.reduce((sum, h) => sum + h.reactionTime, 0) / validHits.length;
                document.getElementById('avgTime').textContent = `${Math.round(avgTime)}ms`;
            }
        }

        function stopGame() {
            endGame();
        }

        async function endGame() {
            gameState.isPlaying = false;
            
            // Clean up
            if (gameState.currentTarget) {
                clearTimeout(gameState.currentTarget.timeout);
                gameState.currentTarget.element.remove();
                gameState.currentTarget = null;
            }

            // Hide game UI
            gameHUD.classList.add('hidden');
            stopBtn.classList.add('hidden');

            // Save session
            const session = {
                playerName: gameState.playerName,
                date: new Date().toISOString(),
                difficulty: gameState.difficulty,
                hits: gameState.hits,
                misses: gameState.misses,
                totalTargets: 40
            };

            saveSession(session);
            updateStats();

            // Get AI analysis
            await getAIAnalysis(session);

            // Show menu
            mainMenu.classList.remove('hidden');
        }

        async function getAIAnalysis(session) {
            aiAnalysisContainer.classList.remove('hidden');
            aiAnalysisText.innerHTML = '<span class="loading"></span> Analyzing your performance...';

            try {
                const validHits = session.hits.filter(h => h.hit && h.reactionTime);
                const avgTime = validHits.length > 0 
                    ? validHits.reduce((sum, h) => sum + h.reactionTime, 0) / validHits.length 
                    : 0;
                
                const accuracy = ((validHits.length / 40) * 100).toFixed(1);

                // Get previous sessions for context
                const allSessions = getSessions();
                const playerSessions = allSessions.filter(s => s.playerName === session.playerName);

                const prompt = `You are an AI performance coach analyzing a hand-eye coordination training session. 

Session Data:
- Difficulty: ${gameState.difficultySettings[session.difficulty].name}
- Hits: ${validHits.length}/40
- Misses: ${session.misses}
- Accuracy: ${accuracy}%
- Average Reaction Time: ${Math.round(avgTime)}ms
- Previous Sessions: ${playerSessions.length - 1}

Provide a concise, encouraging 2-4 sentence analysis of this performance. Focus on strengths, areas for improvement, and actionable next steps. Be motivating but realistic.`;

                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 1000,
                        messages: [
                            { role: 'user', content: prompt }
                        ]
                    })
                });

                const data = await response.json();
                const analysis = data.content[0].text;
                aiAnalysisText.textContent = analysis;
            } catch (error) {
                console.error('AI Analysis error:', error);
                const validHits = session.hits.filter(h => h.hit && h.reactionTime);
                const avgTime = validHits.length > 0 
                    ? validHits.reduce((sum, h) => sum + h.reactionTime, 0) / validHits.length 
                    : 0;
                
                aiAnalysisText.textContent = `Great session! You hit ${validHits.length}/40 targets with an average reaction time of ${Math.round(avgTime)}ms. ${session.misses > 10 ? 'Focus on accuracy in your next session.' : 'Keep up the excellent accuracy!'}`;
            }
        }

        // Data persistence
        function loadPlayerData() {
            const saved = localStorage.getItem('arTapAttack_playerName');
            if (saved) {
                gameState.playerName = saved;
                playerNameInput.value = saved;
            }
        }

        function savePlayerData() {
            localStorage.setItem('arTapAttack_playerName', gameState.playerName);
        }

        function getSessions() {
            const saved = localStorage.getItem('arTapAttack_sessions');
            return saved ? JSON.parse(saved) : [];
        }

        function saveSession(session) {
            const sessions = getSessions();
            sessions.push(session);
            localStorage.setItem('arTapAttack_sessions', JSON.stringify(sessions));

            // Update best average time
            const validHits = session.hits.filter(h => h.hit && h.reactionTime);
            if (validHits.length > 0) {
                const avgTime = validHits.reduce((sum, h) => sum + h.reactionTime, 0) / validHits.length;
                const currentBestAvg = localStorage.getItem('arTapAttack_bestAvgTime');
                if (!currentBestAvg || avgTime < parseFloat(currentBestAvg)) {
                    localStorage.setItem('arTapAttack_bestAvgTime', avgTime.toString());
                }
                
                // Update best single reaction time
                const fastestHit = Math.min(...validHits.map(h => h.reactionTime));
                const currentBestSingle = localStorage.getItem('arTapAttack_bestSingleTime');
                if (!currentBestSingle || fastestHit < parseFloat(currentBestSingle)) {
                    localStorage.setItem('arTapAttack_bestSingleTime', fastestHit.toString());
                }
            }
        }

        function updateStats() {
            const sessions = getSessions();
            const playerSessions = sessions.filter(s => s.playerName === gameState.playerName);

            if (playerSessions.length > 0) {
                const lastSession = playerSessions[playerSessions.length - 1];
                const validHits = lastSession.hits.filter(h => h.hit && h.reactionTime);
                
                if (validHits.length > 0) {
                    const lastAvg = validHits.reduce((sum, h) => sum + h.reactionTime, 0) / validHits.length;
                    document.getElementById('lastTime').textContent = `${Math.round(lastAvg)}ms`;
                }

                const lastAccuracy = ((validHits.length / 40) * 100).toFixed(0);
                document.getElementById('accuracy').textContent = `${lastAccuracy}%`;
            }

            const bestAvgTime = localStorage.getItem('arTapAttack_bestAvgTime');
            if (bestAvgTime) {
                document.getElementById('bestAvg').textContent = `${Math.round(parseFloat(bestAvgTime))}ms`;
            }
            
            const bestSingleTime = localStorage.getItem('arTapAttack_bestSingleTime');
            if (bestSingleTime) {
                document.getElementById('bestSingle').textContent = `${Math.round(parseFloat(bestSingleTime))}ms`;
            }
        }

        // Utility functions
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
