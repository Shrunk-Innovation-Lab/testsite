<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Drawing Markup Station - Electranet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f9fafb; /* gray-50 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #9ca3af; /* gray-400 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        .tool-button.active {
            background-color: #203136; /* New Electranet Dark Blue/Gray */
            color: white;
            border-color: #203136; /* New Electranet Dark Blue/Gray */
        }
        #drawingCanvas {
            /* Default cursor is set dynamically by the active tool */
        }
        #file-list-container {
            max-height: 200px; 
            overflow-y: auto;
        }
        .file-item-row:hover {
            background-color: #f3f4f6; /* gray-100 */
            cursor: pointer;
        }
        .selected-folder > li {
            background-color: #dde2e3; /* Lighter shade of new blue/gray */
            color: #203136;
            font-weight: 600;
        }
        .selected-file {
            background-color: #dde2e3; /* Lighter shade of new blue/gray */
        }
        .selected-file td {
             color: #203136; 
        }

        /* Specific cursors for resize handles (applied via JS) */
        .cursor-nwse-resize { cursor: nwse-resize; }
        .cursor-nesw-resize { cursor: nesw-resize; }
        .cursor-ns-resize { cursor: ns-resize; }
        .cursor-ew-resize { cursor: ew-resize; }
        .cursor-move { cursor: move; }
        .cursor-default { cursor: default; }
        .cursor-crosshair { cursor: crosshair; }
    </style>
</head>
<body class="bg-white dark:bg-slate-900">
    <div class="flex flex-col h-screen font-sans">
        <header style="background-color: #203136;" class="text-white p-3 shadow-md flex justify-center items-center relative">
            <img src="https://electranet.com.au/wp-content/uploads/2024/09/Electranet-Logo-Neg.svg" alt="Electranet Logo" class="h-10 mr-4 absolute left-3 top-1/2 -translate-y-1/2 sm:relative sm:left-auto sm:top-auto sm:translate-y-0">
            <h1 class="text-xl font-bold text-center flex-grow">MOBILE DRAWING MARKUP STATION</h1>
        </header>

        <div class="flex flex-1 overflow-hidden">
            <div class="w-full md:w-72 bg-gray-50 dark:bg-gray-800 p-4 space-y-4 border-r border-gray-200 dark:border-gray-700 overflow-y-auto flex flex-col">
                <div>
                    <label for="substation-select" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">Substation:</label>
                    <select id="substation-select" class="bg-white border border-gray-300 text-gray-900 text-sm rounded-md focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500">
                        <option value="">Select Substation</option>
                    </select>
                </div>
                <div class="flex-grow flex flex-col overflow-hidden">
                    <h3 class="text-sm font-semibold text-gray-900 dark:text-white mb-1">Folders</h3>
                    <ul id="folder-list" class="space-y-1 overflow-y-auto text-sm p-1 bg-white dark:bg-gray-700 rounded-md border border-gray-300 dark:border-gray-600 flex-grow">
                        <li class="text-gray-500 dark:text-gray-400 p-2">Select a substation to see folders.</li>
                    </ul>
                </div>
                <div class="flex-grow flex flex-col overflow-hidden">
                    <h3 class="text-sm font-semibold text-gray-900 dark:text-white mb-1">Files in <span id="current-folder-name" class="font-normal">...</span></h3>
                    <div id="file-list-container" class="bg-white dark:bg-gray-700 rounded-md border border-gray-300 dark:border-gray-600 flex-grow overflow-y-auto">
                        <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-600 text-sm">
                            <thead class="bg-gray-100 dark:bg-gray-700 sticky top-0">
                                <tr>
                                    <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Name</th>
                                    <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Modified</th>
                                </tr>
                            </thead>
                            <tbody id="file-list" class="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                                <tr><td colspan="2" class="p-3 text-gray-500 dark:text-gray-400">Select a folder to see files.</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="flex-1 flex flex-col bg-gray-100 dark:bg-slate-800 overflow-hidden">
                <div id="toolbar" class="bg-gray-100 dark:bg-gray-800 p-2 flex items-center justify-start space-x-1.5 shadow-sm border-b border-gray-300 dark:border-gray-700 flex-nowrap overflow-x-auto">
                    <button id="tool-select" title="Select/Edit Shape" class="tool-button text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0" data-tool="select"><i class="fas fa-mouse-pointer"></i></button>
                    <button id="tool-load-trigger" title="Load Image" style="background-color: #203136;" class="text-white hover:opacity-90 focus:ring-4 focus:ring-blue-300 font-medium rounded-md text-sm px-3 py-1.5 dark:focus:ring-blue-800 flex-shrink-0 flex items-center">
                        <i class="fas fa-folder-open"></i><span class="hidden md:inline ml-1.5">Load</span>
                    </button>
                    <input type="file" id="imageLoader" class="hidden" accept="image/*">
                    <button id="tool-save" title="Save Markup" style="background-color: #203136;" class="text-white hover:opacity-90 focus:ring-4 focus:ring-blue-300 font-medium rounded-md text-sm px-3 py-1.5 dark:focus:ring-blue-800 flex-shrink-0 flex items-center">
                        <i class="fas fa-save"></i><span class="hidden md:inline ml-1.5">Save</span>
                    </button>

                    <span class="border-l border-gray-300 dark:border-gray-600 h-6 mx-1 flex-shrink-0"></span>

                    <button id="tool-pen" title="Pen" class="tool-button text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0" data-tool="pen"><i class="fas fa-pencil-alt"></i></button>
                    <button id="tool-highlighter" title="Highlighter" class="tool-button text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0" data-tool="highlighter"><i class="fas fa-marker"></i></button>
                    <button id="tool-line" title="Line" class="tool-button text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0" data-tool="line"><i class="fas fa-slash"></i></button>
                    <button id="tool-rect" title="Rectangle" class="tool-button text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0" data-tool="rect"><i class="far fa-square"></i></button>
                    <button id="tool-circle" title="Circle" class="tool-button text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0" data-tool="circle"><i class="far fa-circle"></i></button>
                    <button id="tool-stamp" title="Stamp" class="tool-button text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0" data-tool="stamp"><i class="fas fa-stamp"></i></button>
                    <button id="tool-text" title="Text" class="tool-button text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0" data-tool="text"><i class="fas fa-font"></i></button>

                    <span class="border-l border-gray-300 dark:border-gray-600 h-6 mx-1 flex-shrink-0"></span>

                    <input type="color" id="tool-color" title="Color" value="#FF0000" class="p-0 h-8 w-8 rounded-md border-2 border-gray-300 dark:border-gray-600 cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-500 flex-shrink-0">
                    <select id="tool-linewidth" title="Line Width/Font Size Base" class="bg-white border border-gray-300 text-gray-900 text-sm rounded-md focus:ring-blue-500 focus:border-blue-500 h-8 p-1 dark:bg-gray-700 dark:border-gray-600 dark:text-white flex-shrink-0">
                        <option value="1">1px (S)</option>
                        <option value="2">2px (S)</option>
                        <option value="3" selected>3px (M)</option>
                        <option value="5">5px (M)</option>
                        <option value="8">8px (L)</option>
                        <option value="12">12px (L)</option>
                        <option value="20">20px (XL)</option>
                    </select>
                    
                    <span class="border-l border-gray-300 dark:border-gray-600 h-6 mx-1 flex-shrink-0"></span>

                    <button id="tool-undo" title="Undo" class="text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 disabled:opacity-50 disabled:cursor-not-allowed flex-shrink-0" disabled><i class="fas fa-undo"></i></button>
                    <button id="tool-redo" title="Redo" class="text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 disabled:opacity-50 disabled:cursor-not-allowed flex-shrink-0" disabled><i class="fas fa-redo"></i></button>
                    
                    <span class="border-l border-gray-300 dark:border-gray-600 h-6 mx-1 flex-shrink-0"></span>
                    <button id="tool-clear" title="Clear Markups" class="text-white bg-red-600 hover:bg-red-700 focus:ring-4 focus:ring-red-300 font-medium rounded-md text-sm px-3 py-1.5 dark:bg-red-500 dark:hover:bg-red-600 dark:focus:ring-red-800 flex-shrink-0 flex items-center">
                        <i class="fas fa-trash"></i><span class="hidden md:inline ml-1.5">Clear</span>
                    </button>
                    
                    <span class="border-l border-gray-300 dark:border-gray-600 h-6 mx-1 flex-shrink-0"></span>
                    
                    <button id="zoom-in" title="Zoom In" class="text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0"><i class="fas fa-search-plus"></i></button>
                    <button id="zoom-out" title="Zoom Out" class="text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0"><i class="fas fa-search-minus"></i></button>
                    <button id="zoom-reset" title="Reset Zoom/Fit" class="text-gray-700 bg-white border border-gray-300 hover:bg-gray-200 focus:ring-4 focus:ring-gray-200 font-medium rounded-md text-sm px-2.5 py-1.5 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-600 flex-shrink-0"><i class="fas fa-expand-arrows-alt"></i></button>
                </div>
                <div id="canvas-container" class="flex-1 p-4 flex justify-center items-center overflow-auto relative bg-gray-200 dark:bg-slate-700">
                    <canvas id="drawingCanvas" class="border-2 border-gray-400 dark:border-gray-500 shadow-lg bg-white dark:bg-gray-800">Your browser does not support the canvas element.</canvas>
                </div>
            </div>
        </div>

        <footer style="background-color: #203136;" class="text-gray-300 text-sm text-center p-3">
            2025 | Wayout Group Pty Ltd | All Rights Reserved
        </footer>

        <div id="messageBox" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex justify-center items-center p-4">
            <div class="relative bg-white rounded-lg shadow-xl dark:bg-gray-700 w-full max-w-md p-6">
                <h3 id="messageTitle" class="text-lg font-semibold text-gray-900 dark:text-white mb-2">Notification</h3>
                <p id="messageText" class="text-sm text-gray-600 dark:text-gray-300 mb-4"></p>
                <div class="text-right">
                    <button id="messageOkButton" style="background-color: #203136;" class="text-white hover:opacity-90 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center dark:focus:ring-blue-800">
                        OK
                    </button>
                </div>
            </div>
        </div>

        <div id="genericInputModal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex justify-center items-center p-4">
            <div class="relative bg-white rounded-lg shadow-xl dark:bg-gray-700 w-full max-w-md p-6">
                <h3 id="genericInputTitle" class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Input Required</h3>
                <input type="text" id="genericTextInput" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-600 dark:border-gray-500 dark:placeholder-gray-400 dark:text-white mb-4">
                <div class="flex justify-end space-x-3">
                    <button id="genericInputCancelButton" class="text-gray-900 bg-white border border-gray-300 focus:outline-none hover:bg-gray-100 focus:ring-4 focus:ring-gray-200 font-medium rounded-lg text-sm px-5 py-2.5 dark:bg-gray-800 dark:text-white dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 dark:focus:ring-gray-700">
                        Cancel
                    </button>
                    <button id="genericInputOkButton" style="background-color: #203136;" class="text-white hover:opacity-90 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center dark:focus:ring-blue-800">
                        OK
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Mock Data (Simulating file system)
        const APP_DATA = {
            substations: [ 
                {id: "ssd438", name: "Angas Creek - SSD438", folders: [{id: "f5_sld", name: "File 5 - Single Line Diagrams", files: [{ id: "drawing1_aa", name: "310_438_101_001_Rev_AA.png", path: "https://placehold.co/1200x800/FFFFFF/000000?text=Angas+Creek+SLD+1", lastModified: "12/04/2013 17:45pm" }]}]},
                {id: "ssd579", name: "City West - SSD579", folders: [{id: "f7_275kv", name: "File 7 - 275kV Schematics", files: [] }]}
             ],
            uploadedFiles: []
        };
        
        // DOM Elements
        const substationSelect = document.getElementById('substation-select');
        const folderList = document.getElementById('folder-list');
        const fileList = document.getElementById('file-list');
        const currentFolderNameSpan = document.getElementById('current-folder-name');
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const toolbar = document.getElementById('toolbar');
        const colorPicker = document.getElementById('tool-color');
        const lineWidthPicker = document.getElementById('tool-linewidth');
        const imageLoader = document.getElementById('imageLoader');
        const loadTriggerButton = document.getElementById('tool-load-trigger');
        const saveButton = document.getElementById('tool-save');
        const clearButton = document.getElementById('tool-clear');
        const zoomInButton = document.getElementById('zoom-in');
        const zoomOutButton = document.getElementById('zoom-out');
        const zoomResetButton = document.getElementById('zoom-reset');
        const canvasContainer = document.getElementById('canvas-container');
        
        const messageBox = document.getElementById('messageBox');
        const messageTitleElement = document.getElementById('messageTitle'); 
        const messageTextElement = document.getElementById('messageText'); 
        const messageOkButton = document.getElementById('messageOkButton');

        const undoButton = document.getElementById('tool-undo');
        const redoButton = document.getElementById('tool-redo');
        const selectToolButton = document.getElementById('tool-select');


        const genericInputModal = document.getElementById('genericInputModal');
        const genericInputTitle = document.getElementById('genericInputTitle');
        const genericTextInput = document.getElementById('genericTextInput');
        const genericInputOkButton = document.getElementById('genericInputOkButton');
        const genericInputCancelButton = document.getElementById('genericInputCancelButton');
        let genericInputCallback = null;


        // Application State
        let activeTool = 'select'; // Default to select tool
        let currentColor = colorPicker.value;
        let currentLineWidth = parseInt(lineWidthPicker.value);
        const HIGHLIGHTER_WIDTH_MULTIPLIER = 4; // Highlighter width = currentLineWidth * this
        let isDrawing = false; // For new shapes
        let startX, startY, currentX, currentY;
        let backgroundImage = null;
        
        let markups = []; 
        let markupHistory = []; 
        let historyIndex = -1; 

        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        
        let initialCanvasWidth = 800; 
        let initialCanvasHeight = 600;

        // State for moving/resizing
        let selectedMarkupIndex = -1;
        let isDragging = false; // For moving selected shape
        let isResizing = false; // For resizing selected shape
        let resizeHandle = null; // e.g., 'tl', 'tr', 'bl', 'br', 't', 'b', 'l', 'r', 'p1', 'p2'
        let HANDLE_SIZE = 8; // Base handle size, will be scaled by zoomLevel for drawing
        let dragOffsetX, dragOffsetY; // Offset for dragging shape


        // --- Initialization ---
        function init() {
            populateSubstations(); 
            setupEventListeners();
            setActiveTool(activeTool); 
            resizeCanvas(); 
            addMarkupToHistory(); 
            updateUndoRedoButtons();
            showSystemMessage("Welcome!", "Select a substation or load an image to begin. Use the pointer tool to move/resize shapes.");
            window.addEventListener('resize', resizeCanvasAndRedraw);
        }

        function resizeCanvas() {
            const containerWidth = canvasContainer.clientWidth - 32; 
            const containerHeight = canvasContainer.clientHeight - 32;

            if (backgroundImage) {
                const imageAspectRatio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
                let newWidth = containerWidth;
                let newHeight = newWidth / imageAspectRatio;

                if (newHeight > containerHeight) {
                    newHeight = containerHeight;
                    newWidth = newHeight * imageAspectRatio;
                }
                canvas.width = newWidth;
                canvas.height = newHeight;
            } else {
                const aspectRatio = initialCanvasWidth / initialCanvasHeight;
                let newWidth = containerWidth;
                let newHeight = newWidth / aspectRatio;

                if (newHeight > containerHeight) {
                    newHeight = containerHeight;
                    newWidth = newHeight * aspectRatio;
                }
                canvas.width = Math.max(newWidth, 300); 
                canvas.height = Math.max(newHeight, 200);
            }
            initialCanvasWidth = canvas.width; 
            initialCanvasHeight = canvas.height;
            resetZoomAndPan(false); 
        }
        
        function resizeCanvasAndRedraw() {
            resizeCanvas();
            redrawCanvas();
        }

        function populateSubstations() {
            APP_DATA.substations.forEach(substation => {
                const option = document.createElement('option');
                option.value = substation.id;
                option.textContent = substation.name;
                substationSelect.appendChild(option);
            });
        }

        function populateFolders(substationId) {
            folderList.innerHTML = ''; 
            fileList.innerHTML = '<tr><td colspan="2" class="p-3 text-gray-500 dark:text-gray-400">Select a folder to see files.</td></tr>';
            currentFolderNameSpan.textContent = "...";

            const substation = APP_DATA.substations.find(s => s.id === substationId);
            if (substation && substation.folders.length > 0) {
                substation.folders.forEach(folder => {
                    const li = document.createElement('li');
                    li.textContent = folder.name;
                    li.dataset.folderId = folder.id;
                    li.dataset.substationId = substationId;
                    li.className = 'p-2.5 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-md cursor-pointer text-gray-700 dark:text-gray-200';
                    folderList.appendChild(li);
                });
            } else if (substation) {
                 folderList.innerHTML = '<li class="text-gray-500 dark:text-gray-400 p-2.5">No folders in this substation.</li>';
            } else {
                 folderList.innerHTML = '<li class="text-gray-500 dark:text-gray-400 p-2.5">Select a substation.</li>';
            }
        }

        function populateFiles(substationId, folderId) {
            fileList.innerHTML = ''; 
            const substation = APP_DATA.substations.find(s => s.id === substationId);
            const folder = substation ? substation.folders.find(f => f.id === folderId) : null;

            if (folder) {
                currentFolderNameSpan.textContent = folder.name;
                if (folder.files.length > 0) {
                    folder.files.forEach(file => {
                        const tr = document.createElement('tr');
                        tr.className = 'file-item-row hover:bg-gray-100 dark:hover:bg-gray-700';
                        tr.innerHTML = `
                            <td class="px-3 py-2 whitespace-nowrap text-gray-700 dark:text-gray-200">${file.name}</td>
                            <td class="px-3 py-2 whitespace-nowrap text-gray-500 dark:text-gray-400">${file.lastModified}</td>
                        `;
                        tr.dataset.filePath = file.path;
                        tr.dataset.fileName = file.name;
                        fileList.appendChild(tr);
                    });
                } else {
                    fileList.innerHTML = '<tr><td colspan="2" class="p-3 text-gray-500 dark:text-gray-400">No files in this folder.</td></tr>';
                }
            } else {
                 currentFolderNameSpan.textContent = "...";
                 fileList.innerHTML = '<tr><td colspan="2" class="p-3 text-gray-500 dark:text-gray-400">Folder not found or no files.</td></tr>';
            }
        }

        function setupEventListeners() {
            substationSelect.addEventListener('change', (e) => {
                if (e.target.value) populateFolders(e.target.value);
                else { 
                    folderList.innerHTML = '<li class="text-gray-500 dark:text-gray-400 p-2.5">Select a substation to see folders.</li>';
                    fileList.innerHTML = '<tr><td colspan="2" class="p-3 text-gray-500 dark:text-gray-400">Select a folder to see files.</td></tr>';
                    currentFolderNameSpan.textContent = "...";
                 }
            });
            folderList.addEventListener('click', (e) => {
                const listItem = e.target.closest('li');
                if (listItem && listItem.dataset.folderId) {
                    Array.from(folderList.querySelectorAll('li')).forEach(child => child.classList.remove('selected-folder'));
                    listItem.classList.add('selected-folder');
                    populateFiles(listItem.dataset.substationId, listItem.dataset.folderId);
                }
            });
            fileList.addEventListener('click', (e) => {
                const row = e.target.closest('tr.file-item-row');
                if (row && row.dataset.filePath) {
                     Array.from(fileList.querySelectorAll('tr')).forEach(child => child.classList.remove('selected-file'));
                    row.classList.add('selected-file');
                    loadDrawing(row.dataset.filePath, row.dataset.fileName);
                }
            });

            toolbar.addEventListener('click', (e) => {
                const button = e.target.closest('button[data-tool]');
                if (button && button.dataset.tool) {
                    setActiveTool(button.dataset.tool);
                }
            });

            colorPicker.addEventListener('input', (e) => currentColor = e.target.value);
            lineWidthPicker.addEventListener('change', (e) => currentLineWidth = parseInt(e.target.value));

            loadTriggerButton.addEventListener('click', () => imageLoader.click());
            imageLoader.addEventListener('change', handleImageUpload);
            saveButton.addEventListener('click', saveMarkup);
            clearButton.addEventListener('click', clearAllMarkups);
            undoButton.addEventListener('click', undo);
            redoButton.addEventListener('click', redo);

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseout', handleMouseOut); 
            canvas.addEventListener('wheel', handleZoomScroll, { passive: false }); 

            zoomInButton.addEventListener('click', () => applyZoom(1.2));
            zoomOutButton.addEventListener('click', () => applyZoom(1 / 1.2));
            zoomResetButton.addEventListener('click', () => { resizeCanvas(); resetZoomAndPan(); });
            
            messageOkButton.addEventListener('click', () => messageBox.classList.add('hidden'));
            genericInputOkButton.addEventListener('click', () => {
                if (genericInputCallback) genericInputCallback(genericTextInput.value);
                genericInputModal.classList.add('hidden');
            });
            genericInputCancelButton.addEventListener('click', () => {
                if (genericInputCallback) genericInputCallback(null); 
                genericInputModal.classList.add('hidden');
            });
        }

        function addMarkupToHistory() {
            if (historyIndex < markupHistory.length - 1) {
                markupHistory = markupHistory.slice(0, historyIndex + 1);
            }
            markupHistory.push(JSON.parse(JSON.stringify(markups))); 
            historyIndex = markupHistory.length - 1;
            updateUndoRedoButtons();
        }
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                markups = JSON.parse(JSON.stringify(markupHistory[historyIndex]));
                selectedMarkupIndex = -1; 
                redrawCanvas();
                updateUndoRedoButtons();
            }
        }
        function redo() {
            if (historyIndex < markupHistory.length - 1) {
                historyIndex++;
                markups = JSON.parse(JSON.stringify(markupHistory[historyIndex]));
                selectedMarkupIndex = -1; 
                redrawCanvas();
                updateUndoRedoButtons();
            }
        }
        function updateUndoRedoButtons() {
            undoButton.disabled = historyIndex <= 0;
            redoButton.disabled = historyIndex >= markupHistory.length - 1;
        }

        function setActiveTool(tool) {
            activeTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`tool-${tool}`);
            if (activeBtn) activeBtn.classList.add('active');
            
            // Set canvas cursor based on the active tool
            if (tool === 'select') {
                canvas.className = 'cursor-default border-2 border-gray-400 dark:border-gray-500 shadow-lg bg-white dark:bg-gray-800';
            } else if (['pen', 'highlighter', 'line', 'rect', 'circle', 'stamp', 'text'].includes(tool)) {
                canvas.className = 'cursor-crosshair border-2 border-gray-400 dark:border-gray-500 shadow-lg bg-white dark:bg-gray-800';
            }

            if (tool !== 'select' && selectedMarkupIndex !== -1) {
                selectedMarkupIndex = -1; 
                redrawCanvas();
            }
        }
        
        function showGenericInputDialog(title, defaultValue, callback) {
            genericInputCallback = callback;
            genericInputTitle.textContent = title;
            genericTextInput.value = defaultValue;
            genericInputModal.classList.remove('hidden');
            genericTextInput.focus();
            genericTextInput.select();
        }
        function calculateFontSize(lineWidth) { return 10 + (lineWidth * 1.5); }

        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            const canvasX = (clientX - rect.left) * (canvas.width / rect.width);
            const canvasY = (clientY - rect.top) * (canvas.height / rect.height);
            return { 
                x: (canvasX - panX) / zoomLevel, 
                y: (canvasY - panY) / zoomLevel 
            };
        }

        function handleMouseDown(e) {
            e.preventDefault();
            const pos = getMousePos(e);
            startX = pos.x;
            startY = pos.y;

            if (activeTool === 'select') {
                isDrawing = false; 
                const clickedHandle = getHandleAtPosition(pos.x, pos.y);
                if (selectedMarkupIndex !== -1 && clickedHandle) {
                    isResizing = true;
                    resizeHandle = clickedHandle;
                } else {
                    const clickedMarkupIndex = getMarkupAtPosition(pos.x, pos.y);
                    if (clickedMarkupIndex !== -1) {
                        selectedMarkupIndex = clickedMarkupIndex;
                        isDragging = true;
                        const selectedMarkup = markups[selectedMarkupIndex];
                        if (selectedMarkup.type === 'rect' || selectedMarkup.type === 'text' || selectedMarkup.type === 'stamp') {
                            dragOffsetX = pos.x - selectedMarkup.x;
                            dragOffsetY = pos.y - selectedMarkup.y;
                        } else if (selectedMarkup.type === 'circle') {
                            dragOffsetX = pos.x - selectedMarkup.cx;
                            dragOffsetY = pos.y - selectedMarkup.cy;
                        } else if (selectedMarkup.type === 'line') {
                            const distToP1 = Math.sqrt(Math.pow(pos.x - selectedMarkup.x1, 2) + Math.pow(pos.y - selectedMarkup.y1, 2));
                            const distToP2 = Math.sqrt(Math.pow(pos.x - selectedMarkup.x2, 2) + Math.pow(pos.y - selectedMarkup.y2, 2));
                            const handleThreshold = (HANDLE_SIZE * 1.5) / zoomLevel; 
                            
                            if (distToP1 < handleThreshold) {
                                isResizing = true; resizeHandle = 'p1';
                            } else if (distToP2 < handleThreshold) {
                                isResizing = true; resizeHandle = 'p2';
                            } else { 
                                dragOffsetX = pos.x - selectedMarkup.x1; 
                                dragOffsetY = pos.y - selectedMarkup.y1;
                            }
                        }
                    } else {
                        selectedMarkupIndex = -1; 
                        isDragging = false;
                    }
                }
            } else { 
                isDrawing = true;
                isDragging = false;
                isResizing = false;
                selectedMarkupIndex = -1; 

                if (activeTool === 'stamp') {
                    isDrawing = false; 
                    showGenericInputDialog("Enter Stamp Text", "APPROVED", (stampText) => {
                        if (stampText) { 
                            markups.push({ type: 'stamp', text: stampText, color: currentColor, x: startX, y: startY, fontSize: calculateFontSize(currentLineWidth) });
                            addMarkupToHistory(); redrawCanvas();
                        }
                    });
                    return; 
                } else if (activeTool === 'text') {
                    isDrawing = false;
                    showGenericInputDialog("Enter Text", "", (textInput) => {
                        if (textInput) {
                             markups.push({ type: 'text', text: textInput, color: currentColor, x: startX, y: startY, fontSize: calculateFontSize(currentLineWidth) });
                            addMarkupToHistory(); redrawCanvas();
                        }
                    });
                    return;
                }
                if (activeTool === 'pen') {
                    markups.push({ type: activeTool, color: currentColor, lineWidth: currentLineWidth, points: [{ x: startX, y: startY }] });
                } else if (activeTool === 'highlighter') {
                    markups.push({ type: activeTool, color: currentColor, lineWidth: currentLineWidth * HIGHLIGHTER_WIDTH_MULTIPLIER, points: [{ x: startX, y: startY }] });
                }
            }
            redrawCanvas();
        }

        function handleMouseMove(e) {
            const pos = getMousePos(e); 
            if (!isDrawing && !isDragging && !isResizing) { 
                 if (activeTool === 'select') { 
                    let newCursorClass = 'cursor-default';
                    if (selectedMarkupIndex !== -1) {
                        const handle = getHandleAtPosition(pos.x, pos.y);
                        if (handle) {
                            const selectedMarkup = markups[selectedMarkupIndex];
                            if (selectedMarkup.type === 'rect') {
                                if (handle === 'tl' || handle === 'br') newCursorClass = 'cursor-nwse-resize';
                                else if (handle === 'tr' || handle === 'bl') newCursorClass = 'cursor-nesw-resize';
                                else if (handle === 't' || handle === 'b') newCursorClass = 'cursor-ns-resize';
                                else if (handle === 'l' || handle === 'r') newCursorClass = 'cursor-ew-resize';
                            } else if (selectedMarkup.type === 'circle') {
                                if (handle === 'tl_circle' || handle === 'br_circle') newCursorClass = 'cursor-nwse-resize';
                                else if (handle === 'tr_circle' || handle === 'bl_circle') newCursorClass = 'cursor-nesw-resize';
                            } else if (selectedMarkup.type === 'line') {
                                if (handle === 'p1' || handle === 'p2') newCursorClass = 'cursor-move'; 
                            }
                        } else if (getMarkupAtPosition(pos.x, pos.y) !== -1) {
                            newCursorClass = 'cursor-move';
                        }
                    }
                    const currentCursorClass = canvas.className.split(' ').find(cls => cls.startsWith('cursor-'));
                    if (currentCursorClass !== newCursorClass) { 
                        canvas.className = `border-2 border-gray-400 dark:border-gray-500 shadow-lg bg-white dark:bg-gray-800 ${newCursorClass}`;
                    }
                }
                return;
            }

            e.preventDefault();
            currentX = pos.x;
            currentY = pos.y;

            if (isDrawing) { 
                if (activeTool === 'pen' || activeTool === 'highlighter') {
                    markups[markups.length - 1].points.push({ x: currentX, y: currentY });
                }
            } else if (isDragging && selectedMarkupIndex !== -1) { 
                const markup = markups[selectedMarkupIndex];
                const newPosX = currentX - dragOffsetX;
                const newPosY = currentY - dragOffsetY;

                if (markup.type === 'rect' || markup.type === 'text' || markup.type === 'stamp') {
                    markup.x = newPosX;
                    markup.y = newPosY;
                } else if (markup.type === 'circle') {
                    markup.cx = newPosX;
                    markup.cy = newPosY;
                } else if (markup.type === 'line') {
                    const dxOriginal = markup.x2 - markup.x1; // Original length/orientation
                    const dyOriginal = markup.y2 - markup.y1;
                    markup.x1 = newPosX; 
                    markup.y1 = newPosY;
                    markup.x2 = markup.x1 + dxOriginal;
                    markup.y2 = markup.y1 + dyOriginal;
                }
            } else if (isResizing && selectedMarkupIndex !== -1) { 
                const markup = markups[selectedMarkupIndex];
                if (markup.type === 'rect') {
                    if (resizeHandle === 'tl') { markup.width += markup.x - currentX; markup.height += markup.y - currentY; markup.x = currentX; markup.y = currentY; }
                    else if (resizeHandle === 'tr') { markup.width = currentX - markup.x; markup.height += markup.y - currentY; markup.y = currentY; }
                    else if (resizeHandle === 'bl') { markup.width += markup.x - currentX; markup.height = currentY - markup.y; markup.x = currentX; }
                    else if (resizeHandle === 'br') { markup.width = currentX - markup.x; markup.height = currentY - markup.y; }
                    else if (resizeHandle === 't') { markup.height += markup.y - currentY; markup.y = currentY; }
                    else if (resizeHandle === 'b') { markup.height = currentY - markup.y; }
                    else if (resizeHandle === 'l') { markup.width += markup.x - currentX; markup.x = currentX; }
                    else if (resizeHandle === 'r') { markup.width = currentX - markup.x; }
                    if (markup.width < 5) markup.width = 5; 
                    if (markup.height < 5) markup.height = 5; 
                } else if (markup.type === 'circle') {
                    let newRadius;
                    if (resizeHandle === 'tl_circle') { newRadius = Math.max(Math.abs(markup.cx - currentX), Math.abs(markup.cy - currentY)); }
                    else if (resizeHandle === 'tr_circle') { newRadius = Math.max(Math.abs(currentX - markup.cx), Math.abs(markup.cy - currentY)); }
                    else if (resizeHandle === 'bl_circle') { newRadius = Math.max(Math.abs(markup.cx - currentX), Math.abs(currentY - markup.cy)); }
                    else if (resizeHandle === 'br_circle') { newRadius = Math.max(Math.abs(currentX - markup.cx), Math.abs(currentY - markup.cy)); }
                    else { 
                        newRadius = Math.sqrt(Math.pow(currentX - markup.cx, 2) + Math.pow(currentY - markup.cy, 2));
                    }
                    markup.radius = newRadius > 1 ? newRadius : 1;
                } else if (markup.type === 'line') {
                    if (resizeHandle === 'p1') { markup.x1 = currentX; markup.y1 = currentY; }
                    else if (resizeHandle === 'p2') { markup.x2 = currentX; markup.y2 = currentY; }
                }
            }
            redrawCanvas();
        }

        function handleMouseUp(e) {
            if (isDrawing) { 
                isDrawing = false;
                let actionTaken = false;
                if (activeTool === 'line') { markups.push({ type: 'line', color: currentColor, lineWidth: currentLineWidth, x1: startX, y1: startY, x2: currentX, y2: currentY }); actionTaken = true; }
                else if (activeTool === 'rect') { markups.push({ type: 'rect', color: currentColor, lineWidth: currentLineWidth, x: Math.min(startX, currentX), y: Math.min(startY, currentY), width: Math.abs(currentX - startX), height: Math.abs(currentY - startY) }); actionTaken = true; }
                else if (activeTool === 'circle') { const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2)); if (radius > 1) { markups.push({ type: 'circle', color: currentColor, lineWidth: currentLineWidth, cx: startX, cy: startY, radius: radius }); actionTaken = true; } }
                else if (activeTool === 'pen' || activeTool === 'highlighter') { 
                    if (markups.length > 0 && markups[markups.length -1].points.length > 1) actionTaken = true; 
                    else if (markups.length > 0 && markups[markups.length -1].points.length <= 1 ) markups.pop(); // Remove single point "stroke"
                }
                if (actionTaken) addMarkupToHistory();
            } else if (isDragging || isResizing) { 
                if (selectedMarkupIndex !== -1) addMarkupToHistory(); 
            }
            isDrawing = false;
            isDragging = false;
            isResizing = false;
            resizeHandle = null;
            redrawCanvas();
        }
        function handleMouseOut(e){
            if (isDrawing || isDragging || isResizing) {
                handleMouseUp(e);
            }
        }

        function getMarkupAtPosition(x, y) {
            for (let i = markups.length - 1; i >= 0; i--) {
                const markup = markups[i];
                const padding = (markup.lineWidth || 5) / zoomLevel / 2 + 3 / zoomLevel; 
                if (markup.type === 'rect') {
                    if (x >= markup.x - padding && x <= markup.x + markup.width + padding &&
                        y >= markup.y - padding && y <= markup.y + markup.height + padding) return i;
                } else if (markup.type === 'circle') {
                    const dist = Math.sqrt(Math.pow(x - markup.cx, 2) + Math.pow(y - markup.cy, 2));
                    if (dist <= markup.radius + padding) return i;
                } else if (markup.type === 'line') {
                    const { x1, y1, x2, y2 } = markup;
                    const lenSq = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                    if (lenSq === 0) { 
                        if (Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1)) < padding) return i;
                    } else {
                        let t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / lenSq;
                        t = Math.max(0, Math.min(1, t));
                        const projX = x1 + t * (x2 - x1);
                        const projY = y1 + t * (y2 - y1);
                        if (Math.sqrt((x - projX) * (x - projX) + (y - projY) * (y - projY)) < padding) return i;
                    }
                } else if (markup.type === 'text' || markup.type === 'stamp') {
                    ctx.font = markup.type === 'stamp' ? `${markup.fontSize || 20}px Arial Black` : `${markup.fontSize || 16}px Arial`;
                    const textMetrics = ctx.measureText(markup.text);
                    const textWidth = textMetrics.width;
                    const textHeight = markup.fontSize || (markup.type === 'stamp' ? 20 : 16); 
                    
                    if (markup.type === 'stamp') {
                        const stampPadding = padding * 1.5;
                         if (x >= markup.x - textWidth/2 - stampPadding && x <= markup.x + textWidth/2 + stampPadding &&
                            y >= markup.y - textHeight/2 - stampPadding && y <= markup.y + textHeight/2 + stampPadding) return i;
                    } else { 
                        if (x >= markup.x - padding && x <= markup.x + textWidth + padding &&
                            y >= markup.y - padding && y <= markup.y + textHeight + padding) return i;
                    }
                }
            }
            return -1; 
        }

        function getHandleAtPosition(mouseX, mouseY) {
            if (selectedMarkupIndex === -1) return null;
            const markup = markups[selectedMarkupIndex];
            const effectiveHandleRadius = (HANDLE_SIZE / 2) / zoomLevel; 

            const handles = getShapeHandles(markup);
            for (const handle of handles) {
                 const distSq = (mouseX - handle.x) * (mouseX - handle.x) + (mouseY - handle.y) * (mouseY - handle.y);
                 if (distSq <= effectiveHandleRadius * effectiveHandleRadius) {
                    return handle.type;
                }
            }
            return null;
        }
        
        function getShapeHandles(markup) {
            const handles = [];
            if (!markup) return handles;

            if (markup.type === 'rect') {
                const { x, y, width, height } = markup;
                handles.push({ x: x, y: y, type: 'tl' }); 
                handles.push({ x: x + width, y: y, type: 'tr' }); 
                handles.push({ x: x, y: y + height, type: 'bl' }); 
                handles.push({ x: x + width, y: y + height, type: 'br' }); 
                handles.push({ x: x + width / 2, y: y, type: 't' }); 
                handles.push({ x: x + width / 2, y: y + height, type: 'b' }); 
                handles.push({ x: x, y: y + height / 2, type: 'l' }); 
                handles.push({ x: x + width, y: y + height / 2, type: 'r' }); 
            } else if (markup.type === 'circle') {
                const { cx, cy, radius } = markup;
                handles.push({ x: cx - radius, y: cy - radius, type: 'tl_circle' });
                handles.push({ x: cx + radius, y: cy - radius, type: 'tr_circle' });
                handles.push({ x: cx - radius, y: cy + radius, type: 'bl_circle' });
                handles.push({ x: cx + radius, y: cy + radius, type: 'br_circle' });
            } else if (markup.type === 'line') {
                handles.push({ x: markup.x1, y: markup.y1, type: 'p1' });
                handles.push({ x: markup.x2, y: markup.y2, type: 'p2' });
            }
            return handles;
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.save(); 
            ctx.translate(panX, panY);
            ctx.scale(zoomLevel, zoomLevel);

            if (backgroundImage) { 
                const imgAspectRatio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
                let drawWidth = initialCanvasWidth; let drawHeight = initialCanvasWidth / imgAspectRatio;
                if (drawHeight > initialCanvasHeight) { drawHeight = initialCanvasHeight; drawWidth = drawHeight * imgAspectRatio; }
                const offsetX = (initialCanvasWidth - drawWidth) / 2; const offsetY = (initialCanvasHeight - drawHeight) / 2;
                ctx.drawImage(backgroundImage, offsetX, offsetY, drawWidth, drawHeight);
            } else { 
                ctx.fillStyle = document.documentElement.classList.contains('dark') ? "#111827" : "#f9fafb"; // gray-900 or gray-50
                ctx.fillRect(0,0, initialCanvasWidth, initialCanvasHeight);
                ctx.fillStyle = "#9ca3af"; ctx.font = "20px Arial"; ctx.textAlign = "center";
                ctx.fillText("No image loaded. Select a file or load your own.", initialCanvasWidth / 2, initialCanvasHeight / 2);
            }

            markups.forEach((markup, index) => {
                // Set base styles
                ctx.strokeStyle = markup.color;
                ctx.fillStyle = markup.color;
                ctx.lineCap = 'round'; // Default line cap
                ctx.lineJoin = 'round'; // Default line join
                ctx.globalAlpha = 1.0; // Default alpha

                if (markup.type === 'pen') { 
                    ctx.lineWidth = markup.lineWidth; 
                    ctx.beginPath(); ctx.moveTo(markup.points[0].x, markup.points[0].y);
                    for (let i = 1; i < markup.points.length; i++) ctx.lineTo(markup.points[i].x, markup.points[i].y);
                    ctx.stroke();
                } else if (markup.type === 'highlighter') { 
                    ctx.lineWidth = markup.lineWidth; // Already multiplied when created
                    ctx.lineCap = 'square'; // Specific for highlighter
                    ctx.globalAlpha = 0.3; 
                    ctx.beginPath(); ctx.moveTo(markup.points[0].x, markup.points[0].y);
                    for (let i = 1; i < markup.points.length; i++) ctx.lineTo(markup.points[i].x, markup.points[i].y);
                    ctx.stroke();
                } else if (markup.type === 'line') { 
                    ctx.lineWidth = markup.lineWidth; 
                    ctx.beginPath(); ctx.moveTo(markup.x1, markup.y1); ctx.lineTo(markup.x2, markup.y2); ctx.stroke();
                } else if (markup.type === 'rect') { 
                    ctx.lineWidth = markup.lineWidth; 
                    ctx.strokeRect(markup.x, markup.y, markup.width, markup.height);
                } else if (markup.type === 'circle') { 
                    ctx.lineWidth = markup.lineWidth; 
                    ctx.beginPath(); ctx.arc(markup.cx, markup.cy, markup.radius, 0, 2 * Math.PI); ctx.stroke();
                } else if (markup.type === 'stamp') { 
                    ctx.font = `${markup.fontSize || 20}px Arial Black`; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    ctx.save(); ctx.translate(markup.x, markup.y); ctx.rotate(-Math.PI / 12); ctx.fillText(markup.text, 0, 0); ctx.restore();
                } else if (markup.type === 'text') { 
                    ctx.font = `${markup.fontSize || 16}px Arial`; ctx.textAlign = "left"; ctx.textBaseline = "top";
                    ctx.fillText(markup.text, markup.x, markup.y);
                }
                ctx.globalAlpha = 1.0; // Reset alpha for next markup
                ctx.lineCap = 'round'; // Reset lineCap for next markup
            });

            if (selectedMarkupIndex !== -1 && activeTool === 'select') {
                const selectedMarkup = markups[selectedMarkupIndex];
                ctx.strokeStyle = '#203136'; 
                ctx.lineWidth = 1.5 / zoomLevel; 
                ctx.setLineDash([4 / zoomLevel, 4 / zoomLevel]); 

                const handles = getShapeHandles(selectedMarkup);
                if (selectedMarkup.type === 'rect') {
                    ctx.strokeRect(selectedMarkup.x, selectedMarkup.y, selectedMarkup.width, selectedMarkup.height);
                } else if (selectedMarkup.type === 'circle') {
                    ctx.strokeRect(selectedMarkup.cx - selectedMarkup.radius, selectedMarkup.cy - selectedMarkup.radius, selectedMarkup.radius * 2, selectedMarkup.radius * 2);
                }
                
                ctx.setLineDash([]); 
                ctx.fillStyle = '#203136'; 
                const handleRadius = (HANDLE_SIZE / 2) / zoomLevel;
                handles.forEach(handle => {
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, handleRadius, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
            ctx.restore(); 
        }

        function loadDrawing(filePath, fileName) {
            showSystemMessage("Loading...", `Loading drawing: ${fileName || 'image'}`);
            backgroundImage = new Image();
            backgroundImage.crossOrigin = "Anonymous"; 
            backgroundImage.onload = () => {
                currentDrawingPath = filePath;
                markups = []; markupHistory = []; historyIndex = -1; selectedMarkupIndex = -1;
                addMarkupToHistory(); resizeCanvas(); resetZoomAndPan(); redrawCanvas();
                showSystemMessage("Loaded", `Drawing "${fileName || 'image'}" loaded successfully.`);
            };
            backgroundImage.onerror = () => {
                backgroundImage = null; currentDrawingPath = null;
                markups = []; markupHistory = []; historyIndex = -1; selectedMarkupIndex = -1;
                addMarkupToHistory(); resizeCanvas(); resetZoomAndPan(); redrawCanvas(); 
                showSystemMessage("Error", `Failed to load drawing: ${fileName || filePath}.`, true);
            };
            backgroundImage.src = filePath;
        }
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => loadDrawing(e.target.result, file.name); 
                reader.readAsDataURL(file);
            }
            event.target.value = null; 
        }
        function saveMarkup() {
            if (!backgroundImage && markups.length === 0) {
                showSystemMessage("Nothing to Save", "Please load an image or make some markups first.", true); return;
            }
            const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d');
            const baseWidth = backgroundImage ? backgroundImage.naturalWidth : initialCanvasWidth;
            const baseHeight = backgroundImage ? backgroundImage.naturalHeight : initialCanvasHeight;
            tempCanvas.width = baseWidth; tempCanvas.height = baseHeight;

            if (backgroundImage) tempCtx.drawImage(backgroundImage, 0, 0, baseWidth, baseHeight);
            else { tempCtx.fillStyle = '#FFFFFF'; tempCtx.fillRect(0, 0, baseWidth, baseHeight); }

            const scaleFactor = baseWidth / initialCanvasWidth; 
            markups.forEach(markup => {
                tempCtx.strokeStyle = markup.color; tempCtx.fillStyle = markup.color;
                tempCtx.lineCap = 'round'; tempCtx.lineJoin = 'round';
                tempCtx.globalAlpha = 1.0;

                 if (markup.type === 'pen') {
                    tempCtx.lineWidth = markup.lineWidth * scaleFactor; 
                    tempCtx.beginPath();
                    tempCtx.moveTo(markup.points[0].x * scaleFactor, markup.points[0].y * scaleFactor);
                    for (let i = 1; i < markup.points.length; i++) tempCtx.lineTo(markup.points[i].x * scaleFactor, markup.points[i].y * scaleFactor);
                    tempCtx.stroke();
                } else if (markup.type === 'highlighter') {
                    tempCtx.lineWidth = markup.lineWidth * scaleFactor; // lineWidth is already multiplied
                    tempCtx.lineCap = 'square'; 
                    tempCtx.globalAlpha = 0.3; 
                    tempCtx.beginPath();
                    tempCtx.moveTo(markup.points[0].x * scaleFactor, markup.points[0].y * scaleFactor);
                    for (let i = 1; i < markup.points.length; i++) tempCtx.lineTo(markup.points[i].x * scaleFactor, markup.points[i].y * scaleFactor);
                    tempCtx.stroke();
                } else if (markup.type === 'line') {
                    tempCtx.lineWidth = markup.lineWidth * scaleFactor;
                    tempCtx.beginPath(); tempCtx.moveTo(markup.x1 * scaleFactor, markup.y1 * scaleFactor); tempCtx.lineTo(markup.x2 * scaleFactor, markup.y2 * scaleFactor); tempCtx.stroke();
                } else if (markup.type === 'rect') {
                    tempCtx.lineWidth = markup.lineWidth * scaleFactor;
                    tempCtx.strokeRect(markup.x * scaleFactor, markup.y * scaleFactor, markup.width * scaleFactor, markup.height * scaleFactor);
                } else if (markup.type === 'circle') {
                    tempCtx.lineWidth = markup.lineWidth * scaleFactor;
                    tempCtx.beginPath(); tempCtx.arc(markup.cx * scaleFactor, markup.cy * scaleFactor, markup.radius * scaleFactor, 0, 2 * Math.PI); tempCtx.stroke();
                } else if (markup.type === 'stamp') {
                    const stampFontSize = (markup.fontSize || 20) * scaleFactor;
                    tempCtx.font = `${stampFontSize}px Arial Black`; tempCtx.textAlign = "center"; tempCtx.textBaseline = "middle";
                    tempCtx.save(); tempCtx.translate(markup.x * scaleFactor, markup.y * scaleFactor); tempCtx.rotate(-Math.PI / 12); tempCtx.fillText(markup.text, 0, 0); tempCtx.restore();
                } else if (markup.type === 'text') {
                    const textFontSize = (markup.fontSize || 16) * scaleFactor;
                    tempCtx.font = `${textFontSize}px Arial`; tempCtx.textAlign = "left"; tempCtx.textBaseline = "top";
                    tempCtx.fillText(markup.text, markup.x * scaleFactor, markup.y * scaleFactor);
                }
            });
            const dataURL = tempCanvas.toDataURL('image/png');
            const link = document.createElement('a'); link.href = dataURL;
            const currentFile = APP_DATA.substations.flatMap(s => s.folders).flatMap(f => f.files).find(f => f.path === currentDrawingPath);
            link.download = (currentFile ? currentFile.name.replace(/\.[^/.]+$/, "") : "drawing") + "_markup.png";
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            showSystemMessage("Saved", `Markup saved as ${link.download}`);
        }
        function clearAllMarkups() { 
            if (markups.length > 0 || selectedMarkupIndex !== -1) {
                markups = []; selectedMarkupIndex = -1;
                addMarkupToHistory(); redrawCanvas();
                showSystemMessage("Cleared", "Markups have been cleared.");
            } else showSystemMessage("Info", "No markups to clear.");
        }

        function applyZoom(factor, clientX, clientY) {
            const newZoomLevel = zoomLevel * factor;
            if (newZoomLevel < 0.05 || newZoomLevel > 20) return; 
            const rect = canvas.getBoundingClientRect();
            const mouseXOnCanvas = (clientX !== undefined ? clientX : rect.left + rect.width / 2) - rect.left;
            const mouseYOnCanvas = (clientY !== undefined ? clientY : rect.top + rect.height / 2) - rect.top;
            const worldMouseX = (mouseXOnCanvas - panX) / zoomLevel;
            const worldMouseY = (mouseYOnCanvas - panY) / zoomLevel;
            panX = mouseXOnCanvas - worldMouseX * newZoomLevel;
            panY = mouseYOnCanvas - worldMouseY * newZoomLevel;
            zoomLevel = newZoomLevel;
            redrawCanvas();
        }
        function handleZoomScroll(event) {
            event.preventDefault(); 
            const delta = Math.sign(event.deltaY); 
            applyZoom(delta > 0 ? 1 / 1.1 : 1.1, event.clientX, event.clientY);
        }
        function resetZoomAndPan(doRedraw = true) {
            zoomLevel = 1; panX = 0; panY = 0;
            if (backgroundImage) {
                const canvasAspectRatio = initialCanvasWidth / initialCanvasHeight;
                const imageAspectRatio = backgroundImage.naturalWidth / backgroundImage.naturalHeight;
                zoomLevel = (imageAspectRatio > canvasAspectRatio) ? (initialCanvasWidth / backgroundImage.naturalWidth) : (initialCanvasHeight / backgroundImage.naturalHeight);
                zoomLevel = Math.min(zoomLevel, 1); 
                panX = (initialCanvasWidth - (backgroundImage.naturalWidth * zoomLevel)) / 2;
                panY = (initialCanvasHeight - (backgroundImage.naturalHeight * zoomLevel)) / 2;
            }
            if (doRedraw) redrawCanvas();
        }
        
        function showSystemMessage(title, text, isError = false) {
            messageTitleElement.textContent = title; 
            messageTextElement.textContent = text; 
            messageTitleElement.className = `text-lg font-semibold mb-2 ${isError ? 'text-red-600 dark:text-red-400' : 'text-gray-900 dark:text-white'}`;
            messageBox.classList.remove('hidden');
        }

        init();
    </script>
</body>
</html>
